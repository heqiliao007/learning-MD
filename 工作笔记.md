### vue专题

#### 1.vue如何判断图片已经加载完成？

(1)onerror监听图片加载失败，同理onload监听图片加载完成（vue里为@load）

```
<img :src="item.ImageUrl" @error="defImg()"/>

motheds:
defImg: function () {
    var img = event.srcElement ? event.srcElement : event.target;
    img.src = '../image/img_default_small.png';
    /*如果error的default图片也不存在，则会继续触发 onerror事件，导致死循环，故会出现打开网页时提示 Stack overflow at line: 0 错误。特别说明：如果图片存在，但网络很不通畅，也可能触发 onerror事件。
　　*解决方法：控制它不循环*/
    img.onerror = null;
},


或者
<img :src="item.ImageUrl" :onerror="动态路径"/>

data里用import或者require去引入相对路径

```

(2)利用promise

一个demo

```
const imgs = [
    'https://inews.gtimg.com/newsapp_bt/0/9906123226/1000',
    'https://inews.gtimg.com/newsapp_bt/0/9906123226/1000',
    'https://inews.gtimg.com/newsapp_bt/0/9906123226/1000',
    'https://inews.gtimg.com/newsapp_bt/0/9906123226/1000',
    'https://inews.gtimg.com/newsapp_bt/0/9906123226/1000',
    'https://inews.gtimg.com/newsapp_bt/0/9906123226/1000',
    'https://inews.gtimg.com/newsapp_bt/0/9906123226/1000',
    'https://inews.gtimg.com/newsapp_bt/0/9906123226/1000',
    'https://inews.gtimg.com/newsapp_bt/0/9906123226/1000',
    'https://inews.gtimg.com/newsapp_bt/0/9906123226/1000',
    'https://inews.gtimg.com/newsapp_bt/0/9906123226/1000',
    'https://inews.gtimg.com/newsapp_bt/0/9906123226/1000',
    'https://inews.gtimg.com/newsapp_bt/0/9906123226/1000'
];

function ready(pics) {
    const picsAll = pics.map((imgurl) => {
        imgurl = imgurl + '?v=' + Math.random(); // 仅是为了区分下不同的图片链接
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.src = imgurl;
            img.onload = () => resolve(imgurl);
            img.onerror = () => reject(new Error(imgurl + ' load error'));
        })
    });
    Promise.all(picsAll).then(() => {
        console.log('load all success');
    }).catch((e) => {
        console.log(e);
    })
}
```

#### 2.vue弹窗禁止穿透

```
@touchmove.prevent
```

#### 3.vue重新渲染组件（重置或者更新） 

：key=‘’（此处可触发watch和update）
通过vue key 实现，原理请查看官方文档。所以当key 值变更时，会自动的重新渲染

```
<template>
   <third-comp :key="menuKey"/>
</template>
 
<script>
   export default{
       data(){
          return {
                menuKey:1
            }
       },
       watch:{
             menuTree(){
                ++this.menuKey
            }
       }
}
</script>
```

#### 4.iview如何去动态写表头

  renderHeader 函数

#### 5.vue用命令直接修复ESLint

package.json里将 "lint": "vue-cli-service lint"  修改为 "lint": "vue-cli-service lint eslint --fix" 

#### 6.vue中引入图片路径总结

**css中：**

 background-image: url(‘ ~@/assets/images/icons/loading2.gif’); 

  @是webpack设置的路径名，代表的是src目录，可以在build / webpack.base.conf.js更改设置 

 ~ 是相对于下面的文件路径的意思 

 **html中：**

可以加入‘~’也可以不加入‘~’ 

```
 <img class="pic-404__child left" src="@/assets/404_images/404_cloud.png" alt="404">
```

也可以用相对路径

打包时的路径问题：**

- 图片以及一些静态资源尽量放入src/assets目录内，不要放入static目录内，访问不易出错。以`@/assets/……`方式访问。
- 在写路径时候，尽量不要使用绝对路径，请使用@别名方式访问资源 
- config/index.js内可以设置打包后根目录 ，  assetsPublicPath: '/foreEnd/',*设置资源访问时前缀，当设置后，例如图片，css，js等文件的路径就会变为/foreEnd/……的绝对路径，你也可以设置为  **./** 保持相对路径。* 

#### 7.sync的应用

当子组件要去修改父组件传来的某个值的时候，往往的做法是copy一次，即在data里再定义一次子组件要用的值令其===父组件传过来的值

在调用子组件时使用.sync可以直接在子组件内改变父组件值，不过想要传出来这个已经变化的值还是需要emit去update它

```
子组件内：
props：{
	showChartSign: {
      type: Boolean,
      default: true
    }
}
changeChartSign() {
    this.$emit("update:showChartSign",!this.showChartSign);
}
父组件：
<BaseTBCompose
    :keyType="keyType"
    :showSearch="showSearch"
    :showChartSign.sync="showChartSign"
    @search="search"
    @export="exportTable"
    @keyName="keyName"
    :showExport="showExport"
    :showTB="showTB"
    :searchKey="filter.Name"
></BaseTBCompose>
```

#### 8.父子组件相互传同一个值的问题

```
<Input
    style="width:188px;margin-left: -7px;margin-right: -7px;"
    v-model="searchKeyName"
    size="large"
    placeholder="关键词搜索"
/>
子组件再次监听：
watch: {
	//子组件本身的
    searchKeyName(newVal) {
      // this.searchKey = newVal;
      // console.log(newVal);
      this.$emit("keyName", newVal);
    },
    //接受的父组件的
    searchKey(newVal){
      this.searchKeyName = newVal
    }
  }
 父组件再次更新：
 //关键词搜索
 keyName(val){
 	this.filter.Name = val;
 },
```



#### 9.vue报错问题总结

（1）[Vue warn]: Invalid prop: type check failed for prop "model". Expected Object, got MouseEvent 

found in

解答：button 中的 getEmpPostSalList 传递的是一个事件，是object类型 

 写成 getEmpPostSalList() 即可就是加一个括号

（2）提示value undefined

比如这样一个组件

```
<Select v-model="filter.organizationId" size="large" label-in-value @on-change="changeMng">
	<Option v-for="item in mngs" :value="item.Id" :key="item.Id">{{ item.Name }}</Option>
</Select>

changeMng(data) {
    this.filter.organizationName = data ? data.label || null : null;
    let ID = data ? data.value || null : null;
    this.getStationsByMngId(ID);
}
change改变的时候data参数会随之改变，注意判断data.某属性是否存在的问题
```

#### 10.vue中数据item项循环的问题

```
enterLi: function (index) {
	this.bizMenu[index].showActive = true;
},
leaveLi: function (index) {
	this.bizMenu[index].showActive = false;
},
像这种设置单个项的某个属性 必须要在得到bizMenu的data时去定义初始值bizMenu[i].showActive = true/false而不是在data里循环
```

#### 11.iview等ui组件表单中自定义验证的问题

注意，infoValidate的Name和SavePath等各项对应的是Form-item的prop项

```
<i-form
    :model="addModal.info"
    ref="addModal"
    :rules="addModal.infoValidate"
    label-position="right"
    :label-width="80">
    <Form-item label="标题" prop="Name">
    	<i-input type="text" v-model="addModal.info.Name" placeholder="请输入政策法规名称" 			style="width:200px;">
    	</i-input>
    </Form-item>
</i-form>
```

```
infoValidate: {
    Name: [
        { required: true, message: '请输入名称', trigger: 'blur' }
    ],
// message: '请添加文件'
	SavePath: [
    	{ required: true, validator: validateUpdate, trigger: 'change' }
    ],
},
```

在data的return前去定义这个验证方法，这里写的是一个文件上传的验证，如果按照原来默认的验证，则会有bug，当选择文件后仍然提示有错！

```
computed: {
    uploadList(){
       return this.$refs.upload.fileList
       // return this.addModal.info.Files
    }
  },
  
const validateUpdate = (rule, value, callback) => {
	console.log(this.uploadList);
	//以下这段可以写在this.$nextTick里面
    if (!this.uploadList.length) {
   	 callback(new Error('请添加文件'));
    } else {
    	callback();
	}
};

//打开模态框的时候 
this.$refs.upload.clearFiles();

//这个方法是一个异步验证回调方法 会后执行
this.$refs['addModal'].validate(function (valid) {
        if (!valid) {
        }
}
//编辑时
this.$refs['addModal'].resetFields();
```

#### 12.qs的格式问题

```
qs.stringify({ids: [1, 2, 3]}, { indices: false })
 //形式： ids=1&ids=2&id=3
qs.stringify({ids: [1, 2, 3]}, {arrayFormat: ‘indices‘})
 //形式： ids[0]=1&aids1]=2&ids[2]=3
qs.stringify({ids: [1, 2, 3]}, {arrayFormat: ‘brackets‘})
 //形式：ids[]=1&ids[]=2&ids[]=3
qs.stringify({ids: [1, 2, 3]}, {arrayFormat: ‘repeat‘}) 
//形式： ids=1&ids=2&id=3
```

#### 13.axios的delete接口总结

#### 13.大量数据化的优化

列表优化select和checkbox动态组件

当有大量数据时，整个列表dom会被全部渲染出来，推荐插件vue-virtual-scroller/vue-virtual-scroll-list

 https://github.com/tangbc/vue-virtual-scroll-list 

```
// 
import VirtualList from 'vue-virtual-scroll-list'
components: {
    VirtualList
  },

<CheckboxGroup v-model="checkedArr">
      <virtual-list :size="30" :remain="10">
        <p v-for="item in list" :key="`check${item.value}`" style="height: 30px;">
          <Checkbox :label="item.value">
              <Icon type="logo-twitter"></Icon>
              <span>{{ item.label }}</span>
          </Checkbox>
        </p>
      </virtual-list>
    </CheckboxGroup>
```

大型表单优化

表格优化

#### 14.moment用法

```
this.$moment(this.filter.TM).endOf('day')
```

#### 15.权限操作的详解

简单权限控制

iview-admin

 https://blog.csdn.net/qq_43436432/article/details/84374700 

 canTurnTo会通过第二个参数（用户的权限字段列表）进行匹配，如果当前页面，当前用户是有权限的，显示当前页面，否则跳转到401页面 
component，代表组件级别的路由权限  为true，代表可以访问这个页面
为false代表访问不了
这种方式有一个弊端，路由实例里每一个路由都要有一个name
并且不能和path重复

 进行权限过滤时候，过滤的就是routerMap数组，匹配不到直接显示404页面 

#### 16.vue判断iframe加载是否完成

```

mounted () {
    var _this = this
    const iframe = document.querySelector('#ifra')
    // 处理兼容行问题
    if (iframe.attachEvent) {
      iframe.attachEvent('onload', function () {
        // iframe加载完毕以后执行操作
        console.log('iframe已加载完毕')
      })
    } else {
      iframe.onload = function () {
        // iframe加载完毕以后执行操作
        console.log('iframe已加载完毕')
      }
    }

```

#### 17.vue里的webpack相关配置

vue-cli 3.xvue.config.js

//增加模块

devServer: {

​    // 配置开发环境代理

​    proxy: {

​      // 必须使用/easymock开头的接口才使用该代理

​      '/easymock': {

​        //target: 'https://www.easy-mock.com/mock/5caacf05828c3a52184cd2a0/wjfrontframe',

​        target: 'http://localhost:8081',

​        changeOrigin: true,

​        // 真实接口是/api开头的，使用pathRewrite将/gateway替换为/api

​        // 重定向

​        pathRewrite: {

​          //'^/easymock': ''

​          //本地的user.json文件

​          '/user':'user.json'

​        }

​      }

​    }

  }

  

  npm install http-server

  目录下执行http-server 启动这个接口




### git专题

密钥配对<https://blog.csdn.net/u013778905/article/details/83501204> 

1.克隆到本地 git clone  xxx

2.创建本地仓库 git init

git status 用于显示工作目录和暂存区的状态。使用此命令能看到那些修改被暂存到了, 哪些没有, 哪些文件没有被Git tracked到。
git add . 把代码添加到Git的缓冲区
git commit -m 'xxx' 提交代码并编写日志

创建远程仓库（在github上）

先关联 git remote add origin < remote-project-repository-address > 

比如git remote add origin https://github.com/heqiliao007/xxx

再推送

git push origin master提交代码至线上

	//多人开发 
	git branch //查看分支
	git checkout -b xxx新创建一个分支
	git checkout xxx 切换到某个分支  
	
	git diff //查看不同
	git add .
	git commit -m "提交信息"//提交信息
	git push origin xxx分支 //提交到远程xxx分支
	
	git checkout master // 切换到master分支
	git pull origin master//先拉取一遍别人可能更新了
	
	git merge origin/xxx分支 // 把xxx分支上新增的内容合并到master分支上
	git push // 把master分支的内容提交到线上git push origin master
	
	//git 如何在A分支merge B分支的单个文件
	git checkout -p B file.txt
	
	git reset --soft HEAD^ //撤销本次提交，将本地仓库回滚到上一个版本，工作区和暂存区不变。
	HEAD^表示上个提交版本，HEAD^^表示上上个提交版本，HEAD~n代表前面第n个版本

gitbash 不能复制粘贴的使用快捷键 Ctrl/Shift+Insert 

### JS专题

#### 1.js中if else switch 条件判断的替代方法

```
function condition(test){
　　return({
　　　　　　　　cat :function(){console.log('cat');},
　　　　　　　　dog :function(){console.log('dog');},
　　　　　　　　zhiqiang : function(){console.log('zhiqiang');}
　　　　   }[test] || function(){console.log('我是默认值');}
　　)();
}
dcf();  // 我是默认值
dcf('dog'); // dog

to.meta && setTitle(to.meta.title)  //如果&&之前条件为true，则执行&&之后的
```

#### 2.promise/await新理解

为什么封装axios请求的时候很多人喜欢 外层再去套一层Promise

实际上，return 一个promise对象，这个函数才会有.then .catch这些api方法，

而以下两种方法都是相同的，可以直接操作response.data/res.data.Data

```
export function get (url, data = {}) {
  return new Promise((resolve, reject) => {
    axios.get(url, {params: data})
      .then(response => {
        resolve(response.data)
      }, err => {
        reject(err)
      })
  })
}
```

```
export function get (url, data = {}) {
  return axios.get(url, {params: data}).then((res)=>res.data)
}

序号
 
项目名称
 
项目简称
 
地点
 
服务器数量
 
前端设备       数量
 
运维负责人
 
电话
 
现场项目     负责人
 
电话
```

也可以用axios拦截器

```
axios.interceptors.response.use(function (response) {
  let isLocal = false
  isLocal = isLocalRequest(response.config.url)
  // 要根据后端接口调整
  if (!isLocal) {
    if (response.status === 200 && !response.data.Code) {
      return response.data
    } else if (response.status === 200 && (response.data.Code && response.data.Code === 200)) {
      return response.data.Data
    } else {
      handleResposeError(response)
    }
  } else {
    if (response.status === 200) {
      return response.data
    }
  }
  return response
}, function (error) {
  // 对响应错误做点什么
  handleResposeError(error.response)
  return Promise.reject(error)
})
```

封装http部分

```
//get 返回的是http请求
export const getHttp = ({ url, params, options = {} }) => {
  return httpRequest({ url, params, options })
}
//post
export const postHttp = ({ url, params, data, options = {} }) => {
  return httpRequest({ url, params, data, method: httpPostMethod, options })
}

/ * 公用HTTP请求
 * @param url       接口地址
 * @param params    query参数对象
 * @param data      body参数对象
 * @param options   配置参数，覆盖默认配置
 */
export const httpRequest = ({ url, params, data, method = httpGetMethod, options = {} }) => {
  const defalutOptions = {
    headers: {
      ...getContentType('json')
    },
    config: {},
    isUseFormData: false, // 是否需要将data转换为formData
    isAutoDealError: true // 设置是否自动处理错误信息,默认是true,设置为false则页面自己处理错误
  }

  const setOptions = {
    ...defalutOptions,
    ...options
  }
  if (setOptions.isUseFormData) {
    data = qs.stringify(data)
  }
  if (!setOptions.isAutoDealError) {
    const customerDealErrorHeader = {
      'X-CustomerDealError': 'true'
    }
    setOptions.headers = {
      ...setOptions.headers,
      ...customerDealErrorHeader
    }
  }
  const axiosConfig = getAxiosConfig(url, params, data, method, setOptions.headers, setOptions.config = {})
  return axios(axiosConfig).then(res => res).catch(error => {
    handleError(error)
  })
}


//某一模块的API.js文件
import apiConfig from '@/config/api.config'
import { getHttp, postHttp, putHttp, delHttp } from '@/utils/apiRequest'

/**
 * 获取项目列表
 * @param {object} parameter 
 */
export const getProjects = parameter => {
  return getHttp({
    url: apiConfig.project.list,
    params: {
      ...parameter
    }
  })
}

/**
 * 获取所有项目列表
 */
export const getAllProjects = (orgid = 0) => {
  return getHttp({
    url: apiConfig.project.all(orgid)
  })
}

/**
 * 添加项目
 * @param {object} parameter 
 */
export const addProject = parameter => {
  return postHttp({
    url: apiConfig.project.add,
    data: {
      ...parameter
    }
  })
}

/**
 * 修改项目
 * @param {object} parameter 
 */
export const updateProject = parameter => {
  return putHttp({
    url: apiConfig.project.update,
    data: {
      ...parameter
    }
  })
}

/**
 * 删除项目
 * @param {string} id 
 */
export const deleteProject = id => {
  return delHttp({
    url: apiConfig.project.delete(id)
  })
}


api.config.js
const apiConfig = {
  project: {
    list: getHost('pm') + '/Api/ProjectBase/Base/Page',
    add: getHost('pm') + '/Api/ProjectBase/Base/Add',
    update: getHost('pm') + '/Api/ProjectBase/Base/Update',
    delete: id => getHost('pm') + `/Api/ProjectBase/Base/Delete/${id}`,
    import: getHost('pm') + '/Api/Import/ProjectBase',
    export: getHost('pm') + '/api/Export/projectbase'
  }
}
```

##### 关于捕捉错误的await写法

```
如果使用promise封装好的函数，会有.catch用于捕捉错误情况下，reject的操作
promise.then(v => {}).catch(e => {})

而async/await中可以这样写
async func(){
  try{
    let res = await promiseFunc()
  }catch(err){
    alert(err)
  }
}
ps: try--catch只能用于同步操作（async/await是同步写法的异步），异步很多无法捕获

补充:promise中catch方法的使用
catch((err) => {
//使用err.response.data来获取具体的信息
var errText = err.response.data.Message;
    this.$Message.error({
        background: true,
        content: errText
    });
    throw err;
});
```



#### 3.求一组数组中的最大最小值，es6优雅写法

 为number类型的数字，可以是小数、整数；正数、负数、0. 

item.HTZ= accuracyFix(item.HTZ);

if(item.HTZ != null) arrHTZ.push(Math.round(item.HTZ))

// 历史最高水位

data.maxHTZ = Math.max(...(arrHTZ));

#### 4.js中浮点数计算的精度丢失

比如 

```
0.1 + 0.2 == 0.30000000000000004 （多了 0.00000000000004）
0.2 + 0.4 == 0.6000000000000001 （多了 0.0000000000001）
19.9 * 100 == 1989.9999999999998 （少了 0.0000000000002）
```

使用Math.round四舍五入

Math.round((item.MXQ )*100)

#### 5.兼容性放大缩小元素或网页的做法

zoom本身兼容IE6、IE7、IE8浏览器 ，但是不兼容火狐浏览器

zoom缩放会将元素保持在左上角，而scale默认是中间位置，可以通过transform-origin来设置 

兼容写法：

```
if (userAgent.indexOf('Firefox') > -1) {
    document.getElementById('zoom').style.transform = 'scale(' + 1000 / 500 + ')'
    document.getElementById('zoom').style.transformOrigin = 'top'
} else {
	document.getElementById('zoom').style.zoom = 1000 / 500
}
```

#### 6.echart的方法总结及封装，解决空白、变形bug的方法

v-if切换的时候echarts的数据需要在this.$nextTick(()=>{})里去获取，否则会空白，并且会报错cant get attribute属性

v-show切换的时候会变形，此时是因为dom还没渲染出来，无法知道echartsdom元素的具体宽高，这时候可以在echarts元素上加上具体宽高，但是无法应用于自适应，最好的办法还是tab切换的时候在this.$nextTick(()=>{})去resize

```
this.$nextTick(() => {
	this.chartRing.resize();
});
```

此外还要考虑放大缩小情况下echarts的变形问题，及监听和销毁echarts组件里的全局对象

```
/*
 * 地下水查询分析图表 封装示例
*/

<template>
  <!-- 地下水查询统计查询 图表 -->
  <div ref="chart" :style="style"></div>
</template>

<script>
import echarts from "echarts";
import { accuracyFix } from "@/util/util";

export default {
  data() {
    return {
      chart: null,
      grid: {
        top: 50,
        bottom: 80,
      },
      tooltip: {
        trigger: "axis",
        confine:true,
        position: function(pt) {
          return [pt[0], "10%"];
        }
      },
      legend: {
        show: false,
        selected: {}
      },
      dataZoom: [
        // {
        //   show: true,
        //   realtime: true,
        //   start: 0,
        //   end: 100
        // },
        // {
        //   type: "inside",
        //   realtime: true,
        //   start: 0,
        //   end: 100
        // }
        {
          type: "inside",
          start: 0,
          end: 100
        },
        {
          start: 0,
          end: 100,
          handleIcon:
            "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4v1.3h1.3v-1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7V23h6.6V24.4z M13.3,19.6H6.7v-1.4h6.6V19.6z",
          handleSize: "80%",
          handleStyle: {
            color: "#fff",
            shadowBlur: 3,
            shadowColor: "rgba(0, 0, 0, 0.6)",
            shadowOffsetX: 2,
            shadowOffsetY: 2
          }
        }
      ],
      xAxis: {
        type: "category",
        boundaryGap: false,
        color: "#ddd",
        data: []
      },
      yAxis: [
        {
          name: "水位\n(m)",
          type: "value",
          splitArea: {
              show: true
          },
          splitLine: {
            show: false
          },
          // max: function(value) {
          //   return accuracyFix(value.max + (value.max - value.min) * 0.1);
          // },
          min:function(value) {
            if(value.min>=0){
              return accuracyFix(value.min*0.8);
            }else{
              return accuracyFix(value.min/0.8);
            }
          }
        },
        // {
        //   name: "流量\n(m³/s)",
        //   type: "value",
        //   splitLine: {
        //     show: false
        //   }
        //   // max: function(value) {
        //   //   return accuracyFix(value.max + (value.max - value.min) * 0.1);
        //   // },
        //   // min: function(value) {
        //   //   return accuracyFix(value.min - (value.max - value.min) * 0.1);
        //   // }
        // }
      ],
      series: []
    };
  },
  props: {
    height: {
      type: String,
      default: "100%"
    },
    width: {
      type: String,
      default: "100%"
    },
    ydata: {
      type: Array,
      default: function() {
        return [
          {
            name: "水位\n(m)",
            color: "#ddd"
          },
          // {
          //   name: "流量\n(m³/s)",
          //   color: "#ddd"
          // }
        ];
      }
    },
    option: {
      type: Object,
      default: function() {
        return {
          series: [],
          dataX: []
        };
      }
    },
    select: {
      type: Array,
      default: function() {
        return [];
      }
    },
    state: {
      type: Boolean,
      default: function() {
        return true;
      }
    }
  },
  mounted() {
    this.$nextTick(() => {
      setTimeout(() => {
        this.init();
      }, 300);
    });
  },
  beforeDestroy() {
    if (this.chart && this.chart.resize) {
      window.removeEventListener("resize", this.chart.resize);
      this.chart.dispose();
    }
  },
  updated() {},
  methods: {
    init() {
      this.legend.selected = this.processLabels(this.select);
      // this.yAxis[0].name = this.ydata[0].name;
      // this.yAxis[0].nameTextStyle.color = this.ydata[0].color;
      // this.yAxis[1].name = this.ydata[1].name;
      // this.yAxis[1].nameTextStyle.color = this.ydata[1].color;
      this.series = this.option.series;
      this.xAxis.data = this.option.dataX;
      // console.log(JSON.stringify(this.setOption));
      this.$nextTick(() => {
        this.chart = echarts.init(this.$refs.chart);
        this.chart.setOption(this.setOption);
        window.addEventListener("resize", this.chart.resize); // 图表响应大小的关键,重绘
      });
    },

    // 处理labels
    processLabels(labels = []) {
      let selected = {};
      if (labels.length) {
        labels.forEach(item => {
          selected[item.label] = item.isChoose;
        });
      }
      return selected;
    }
  },
  computed: {
    setOption() {
      return {
        grid: this.grid,
        legend: this.legend,
        tooltip: this.tooltip,
        dataZoom: this.dataZoom,
        xAxis: this.xAxis,
        yAxis: this.yAxis,
        series: this.series
      };
    },
    style() {
      return {
        height: this.height,
        width: this.width
      };
    }
  },
  watch: {
    option: {
      handler: function(newVal) {
        if (this.chart) {
          this.series = newVal.series;
          this.xAxis.data = newVal.dataX;
          this.chart.setOption(this.setOption);
        } else {
          setTimeout(() => {
            this.init();
          }, 300);
        }
      },
      deep: true
    },
    select: {
      handler: function(newVal) {
        this.legend.selected = this.processLabels(newVal);
        if (this.chart) {
          this.chart.setOption(this.setOption);
        }
      },
      deep: true
    },
    state: {
      handler: function(newVal) {
        if (this.chart && this.chart.resize) {
          setTimeout(() => {
            this.chart.resize();
          }, 220);
        }
      }
    }
  }
};
</script>

<style scoped lang="scss"></style>

```

echart点击事件

```
// 每次生成图像前先解绑事件
myChart.off('click');
// 点击筛选
myChart.on('click', function eConsole(param) {
    if(param.dataIndex === 0){
    	//self.abnormalEqu(self.deviceIndex)
    }else if(param.dataIndex === 1){
    	//self.normalEqu(self.deviceIndex)
    }
});
```

echarts图外保存

 https://segmentfault.com/a/1190000021008197?utm_source=tag-newest 

#### 7.indexOf的一些用法

```
// indexOf === 0表示是否以以value开头
record.name.indexOf(value) === 0
// 如果>-1 大于-1就是包含,-1表示不包含
```

#### 8.js方法的链式写法（优雅写法）

```
onFilter: (value, record) =>
    record.name
        .toString()
        .toLowerCase()
        .includes(value.toLowerCase()),
```

#### 9.this引发的undefined错误

```
this.$http.get(`${this.serverUrl}/WaterUserUnit/GetIrrigationWaterUserUnits`,
                {
                    params:{
                        organizationId: this.filter.organizationId || '0'
                    }
                }
            ).then((res) => {
                if (res) {
                    console.log("获取用水单位列表的数据为：", res)
                    this.getWaterGroupList = res.data.Data.length > 0 ? res.data.Data : []
                }
            }).catch((error) => {
                throw error
            })
//then 方法里用箭头函数可以取到this，箭头函数中所使用的this来自于函数作用域链，也就是定义时的this，如果写成then(function(){})则this指向window，但是在webpack构成的项目中，webpack会使用eval模式去使this指向一个空对象{}
```

#### 10.e.preventDefault

会阻止表单提交的时候 重新加载页面 

#### 11.解构赋值结合接口的优雅写法

```
//建议写成这种优雅的写法
.then(({data: { Code, Data }) => {
    console.log(data.Code)
})
//换成await写法
const {data: { Code, Data }} = await xxx
```

#### 12.proxy项目的应用

```
//一份数据用于升序、降序、还原重置，不去改变原数据
data(){
    return {
      proxy: '',
      price: []
    }
},
async mounted () {
	const {data: { Code, Data: {peice} }} = await get('./XXX');
	//冻结原数据
	Object.freeze(price);
	this.proxy = new Proxy({},{
		get(target,key){
			if(target === 'up'){
				return [].contact(price).sort((a,b) => a - b);
			}else if(target === 'down'){
				return [].contact(price).sort((a,b) => b - a);
			}else{
			 	return price;
			}
		},
		set(){
			return false;
		}
	})
	this.price = this.proxy.default
},
methods:{
    up(){
    	this.price = this.proxy.up
    },
    down(){
    	this.price = this.proxy.down
    },
    reset(){
    	this.price = this.proxy.default
    }
}
```

#### 13.下载图片

```
downloadImg(){
      let el = document.getElementById('makeImg');
      let w = getComputedStyle(el).width;
      let h = getComputedStyle(el).height;

      // alert(this.imageIndex);

      html2Canvas(el,{
        backgroundColor: null
      }).then((canvas) => {
          let imgData = canvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
          let a = document.createElement('a');
          a.href = imgData;
          a.download = 'filename.png';
          a.click();
      });
},
```



### css专题

#### 1.flex的应用

```
父容器设置flex后
display: flex;
（1）换行
flex-wrap: wrap;
nowrap：自动缩小项目，不换行
wrap：换行，且第一行在上方
wrap-reverse：换行，第一行在下面
（2）如果要使里面的元素上下垂直居中
justify-content: center;//x轴排列
align-items: center;//y轴排列
//ps这两个属性一定要设置在父元素上，因为它是对其子元素起作用
（3）align-items和align-content区别
align-items属性可以应用于所有的flex容器，它的作用是设置flex子项在每个flex行的交叉轴上的默认对齐方式。
对一行起作用
align-content 只适用多行的flex容器（也就是flex容器中的子项不止一行时该属性才有效果，最经常的场景就是width>容器宽度时使其换行），它的作用是当flex容器在交叉轴上有多余的空间时，将子项作为一个整体（属性值为：flex-start、flex-end、center时）进行对齐

解析align-items: stretch;
如果项目未设置高度或设为auto，将占满整个容器的高度
特别适用于左右布局 使左右始终一致高的情况下
(4)子元素布局
flex 是 flex-grow、flex-shrink、flex-basis的缩写，默认值是 0 1 auto
如果左侧 80px 右侧100px 中间auto
左：flex: 0 0 80px;
右：flex: 0 0 100px;
中间自适应：flex：auto或者flex：1;

解析flex：1 实际为flex：1 1 0;
flex-grow : 1; // 这意味着div将以与窗口大小相同的比例增长
flex-shrink : 1; // 这意味着div将以与窗口大小相同的比例缩小
flex-basis : 0; // 这意味着div没有这样的起始值，并且将根据可用的屏幕大小占用屏幕。例如： - 如果包装器中有3个div，则每个div将占用33％。

(5)flex-direction: column;
   align-items: center;
   这样写可用于多列居中排列 比如那种上面一个图片 下面几行文字 都居中的情况下
```

#### 2.bg复合缩写几个注意点

background: url('~@/assets/images/indexMenu/'+$link2) top left / 100% no-repeat;

前面指背景位置：background-position，后面指大小：background-size，可以为百分比，具体的宽高值，或者cover(保持横纵比，铺满整个背景)，contain(保持横纵比，依据长的一边显示完整背景图片)

 https://developer.mozilla.org/zh-CN/docs/Web/CSS/background 

background-size若是实际大小或者百分比，要写两个值

#### 3.pointer-events 穿透事件

它能够

阻止用户的点击动作产生任何效果

阻止缺省鼠标指针的显示

阻止CSS里的 `hover `和 `active `状态的变化触发事件

阻止JavaScript点击动作触发的事件

多用于 

遮罩层穿透去操作遮罩层下层的事件

### apiCloud专题

 https://docs.apicloud.com/Dev-Tools/wifi-debug 

```
apiready = function() {
    app.setRefreshHeaderInfo(vm.loadData);
    vm.loadData();
};
apiready函数相当于入口函数，页面开始加载的时候就会加载它，如果页面开始(初始化)就要加载接口数据，需要使用到api.ajax，此时api需要加载完成后才能调用，否则报错未定义，所以，初始加载的ajax一般都需要写在apiready中
在api加载完成后再进行的事件可以在apiready函数外进行调用
```



### ArcGIS API for JavaScript 4.2学习笔记

 [https://www.cnblogs.com/onsummer/tag/ArcGIS%20API%20for%20Javascript/default.html?page=3](https://www.cnblogs.com/onsummer/tag/ArcGIS API for Javascript/default.html?page=3) 

#### 1.显示2D地图

假设vue中，先写一个function去initMap，在mounted去初始化

首先在html页面中肯定要有一个div，官方命名为“viewDiv”，我这里用id=“map”

```
initMap () {
	require
    (
        [
          "esri/Map",
          "esri/views/MapView",
          "dojo/domReady!"
        ] ,
        function(Map, MapView) {
            //你的代码
            var map = new Map({
            	basemap: "osm" // 基础地图类型
            });
            var view = new MapView({
                container: "map",  // 承接地图的块元素的ID
                map: map,  // 地图对象，由上方new出
                zoom: 8,  // 缩放级别
                center: [114, 30]  // 中心经纬度
            });
        }
    );
}
```

 代码解析：

1.1 两个实例化的对象map、view进行解释说明。

【map对象是地图的数据部分，而view则是地图的可视化部分。】

1.2 require入口函数  参数

第一个参数，引用数组。注意第一个参数引用的的图层要和第二个参数中也就是函数里的参数顺序一致

第二个参数是一个函数，函数体就是初始化地图的一些代码

map对象和view对象都是由上面Map和MapView类new实例化出来的。Map和MapView两个名词，是esri/Map模块和esri/views模块下的两个类而已。

1.3 basemap 作为最下面的地图，然后你可以在上面再叠加自己的图层 

官方文档 https://developers.arcgis.com/javascript/3/jsapi/esri.basemaps-amd.html 

踩坑：这17种basemap中只有8种可以通过上述代码的这种方式调用 （national-geographic,gray,hybrid,oceans,osm,satellite卫星图,streets,topo） ，剩余的暂时不知道调用方法

https://www.cnblogs.com/myfgis/p/5709079.html 

1.4 Map

 http://120.78.85.181:5051/doc/sdk47/api-reference/esri-Map.html 

继承自Accessor，子类有WebMap和WebScene。

构造函数的参数有一个：basemap类型的参数

1.5 MapView 2D地图

 http://120.78.85.181:5051/doc/sdk47/api-reference/esri-views-MapView.html 

继承自 MapView [View](http://120.78.85.181:5051/doc/sdk47/api-reference/esri-views-View.html) [Accessor](http://120.78.85.181:5051/doc/sdk47/api-reference/esri-core-Accessor.html) 

SceneView - Create a 3D map(后面介绍)

1.6 官方样式表和类库的引用，没有这俩运行不了

```oz
<link rel="stylesheet" href="https://js.arcgis.com/4.2/esri/css/main.css">
<script src="https://js.arcgis.com/4.2/"></script>
```

#### 2.显示3D地图

view对象不是MapView类了，而是SceneView类 

```
function(Map, SceneView){
  var map = new Map({
    basemap: "osm", 
    ground: "world-elevation"
  });//仍然使用osm基础地图
  var view = new SceneView({
    container: "map",     
    map: map,               
    scale: 50000000,         
    center: [113.5, 30] 
  });//比例尺为1：5000万
}
```

2.1 ground属性

 ground属性是表面数据，它可以是Ground类的实例 ，字符串“world-elevation”使用世界高程服务指定地面的一个实例 

#### 3.sample 样例

 http://120.78.85.181:5051/doc/sdk47/sample-code/webmap-basic/index.html 

【Get Started】

类似于绪论一样的东西，抽取了最需要关注的几个例子。如：加载Map和View，加载layers，使用弹出窗口，视觉化，与使用窗口小部件。

【Mapping and Views】 介绍地图（Map）和视图（View）的 

最基础的，知道地图和视图的区别，能使用2D和3D地图，对地图的布局有一定的了解，对地图的动画也有小小的使用示例。还介绍了2D3D视图同步、鹰眼、指北针等功能。这一章是最基础的了，其中第一小节介绍了入口函数的参数意义

别人写的例子 https://www.cnblogs.com/onsummer/p/6363914.html 

#### 4.Layers

支持多图层叠加显示

支持要素图层、场景图层（直接把影像拔高，推出了一个盒子形状的立体物件的场景图层）、矢量瓦片图层（这个很厉害啊）、影像图层、流图层、CSV图层、OpenStreet地图图层、Web瓦片图层、点云图层（这个更厉害1.1亿的激光雷达点云数据都能加载进来）

其中，对MapImageLayer和ImageryLayer有着重的介绍，前者不知道是什么东西，后者是影像图层（栅格图层）。这也是数据中最关键的了。

最后我想问一下：图层这种东西，是怎么创建的（查API应该可以查到如何创建实例）？数据又如何从硬盘中获取？需要服务器环境吗？

回答上一句提到的问题。图层通过ArcGIS Server发布的各种服务创建，也可以通过Online或者Portal上的ID创建。

 https://www.cnblogs.com/onsummer/p/6363915.html 

##### Create a layer from a portal item

```
Layer.fromPortalItem({
  portalItem: {
    id: "af1ad38816814b7eba3fe74a3b84412d"
  }
}).then(function(lyr){
  // Adds layer to the map
  map.add(lyr);
});
```

#### 5.公有方法和属性

**公有方法**

- emit()：为此view创造事件
- on()：给事件添加处理方法
- when()：Promise的处理方法

**公有属性**

- container：可以给html元素的id字符串，也可以传递DOM；表示该view要绑定到的html元素

- graphics：视图上的几何形状容器

   PictureMarkerSymbol 是对于点或多点要素的 Graphic 对象进行样式设置的类，PictureMarkerSymbol 主要通过图片的 url 或 Drawable 等方式来设置图片符号 

  SimpleMarkerSymbol 也是针对点状要素的 Graphic 对象进行样式设置的类，SimpleMarkerSymbol 与
  PictureMarkerSymbol 类很相似，只不过一个渲染成矢量点，另一个通过图片来替换该点 

  SimpleLineSymbol 是针对线状要素的 Graphic 对象进行样式设置的类，通过它可以设置线状要素的样式，包括线型、线颜色、线宽和线的透明度等 

   SimpleFillSymbol 是对于面状要素的 Graphic 对象进行样式设置的类 

   TextSymbol 也是针对点状要素的 Graphic 对象进行样式设置的类，它将点的位置替换成文字进行标绘显示，
  通过 TextSymbol 可以设置文字的大小、颜色、内容和排列方式 

   样式 SimpleFillSymbol.Style样式枚举共8种  https://www.cnblogs.com/dangpengfei/p/11350134.html 

   SimpleLineSymbol.STYLE_SOLID全色填充 

- map：被绑定的Map对象，即数据部分，见前两篇博客

- popup：弹出窗。每个view都自带一个，如果想删除，设为null即可；如果不为任何图层绑定popupTemplate，则该view的弹出窗内容与图层无关。可以自己实例化一个Popup实例并传递给它。

- spatialReference：坐标系

- type：此view的类型，可以用来判断是2d或者3d视图

- ui：此view上承载的widget容器

#### 5.goTo()地图动画

 http://120.78.85.181:5051/doc/sdk47/sample-code/scene-goto/index.html 

 除了Map类和SceneView类，还多出来了query和on这俩，字面意思可以猜测是查询和事件有关 

```
require(
　　[
　　　　"esri/Map",
　　　　"esri/views/SceneView",
　　　　"dojo/query",
　　　　"dojo/on"
　　　　"dojo/domReady!"
　　]
　　function(Map,SceneView,query,on)
　　{
　　　　//你的代码
　　}
);
```

地图缩放动画的核心就是view对象的goTo()方法的使用。

goTo()方法在MapView类和SceneView类中都有提供，但是在它们的父类View类中没有

 https://www.cnblogs.com/onsummer/p/6388084.html 

#### 6.WebMap\WebMap

网络地图不同于底图，webmap包含一些信息，比如可以加载一个显示国家意外死亡人数的网络地图。在视图中加载一个网络地图，必须要在webmap对象中的portalItem属性中引用webmap的ID。webmap可以从ArcGIS Online 或者 Portal for ArcGIS中加载

#### 7.地图中的操作dom元素

dojo解析

简而言之，操作dom元素的

 **引入dojo的domReady!模块可以让该方法在页面加载完成后再运行** 



domConstruct元素位置操作

 domConstruct.place(操作的元素, 父元素, "位置")；位置：first,before,after 

#### 8.PictureMarkerSymbol

 PictureMarkerSymbol是图中搜索结果的图案所需的模块 

symbol对象4个属性

```
var symbol = {
  type: "picture-marker",  // autocasts as new PictureMarkerSymbol()
  url: "https://static.arcgis.com/images/Symbols/Shapes/BlackStarLargeB.png",
  width: "64px",
  height: "64px"
};
```

 For [PictureMarkerSymbol](https://developers.arcgis.com/javascript/latest/api-reference/esri-symbols-PictureMarkerSymbol.html#type) the type is always ["picture-marker"](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) 

更多message：

 https://developers.arcgis.com/javascript/latest/api-reference/esri-symbols-PictureMarkerSymbol.html 

#### 9.事件

 pointer-up   释放鼠标按键 

legend1.on("mouse-over"）鼠标滑过图标

#### 10.地图服务

ArcGISTiledMapServiceLayer 缓存图片图层

ArcGISDynamicMapServiceLayer动态图层

ArcGISTiledMapServiceLayer可以直接加载服务器端的缓存地图服务，显示效果好，速度快，但它的缺点正是ArcGISDynamicMapServiceLayer的优点，即不支持动态投影，不能控制图层可见性，服务器端需要提前生成缓存等 

#### 11.图层关系

https://blog.csdn.net/vaecer/article/details/50736365 

 IdentifyTask是用来识别图层中的要素的，而QueryTask是用来做图层要素查询的 



### 高德地图

简书博客系列
https://www.jianshu.com/u/f9d821e90fc5 
https://www.jianshu.com/p/4b52d69630c9 

高德官方文档
https://lbs.amap.com/api/javascript-api/reference/core 

官方示例
https://lbs.amap.com/api/javascript-api/guide/abc/basetype 

#### 1.创建地图

```
 var map = new AMap.Map('container', {
     resizeEnable: true, //是否监控地图容器尺寸变化
     zoom:11, //初始化地图层级
     center: [116.397428, 39.90923] //初始化地图中心点
 });
```
#### 2.地图属性

```
//使用Map.setFeatures()方法，定制地图显示的元素类别
var map = new AMap.Map('container', {
    resizeEnable: true, //是否监控地图容器尺寸变化
    showLabel: false //不显示地图文字标记
    zoom: 17,
    center: [116.408075, 39.950187],
    features: ['bg', 'road', 'building', 'point']
    // bg区域面 road道路 building建筑物 point标注
});

//或者map.setFeatures(myFeatures);

//3D地图
var map = new AMap.Map('container', {
    resizeEnable: true, // 地图容器尺寸变化
    rotateEnable:true, // 旋转 写为false将固定视角无法旋转
    pitchEnable:true, // 倾斜  写为false将固定时间无法倾斜
    zoom: 17,
    pitch:80,
    rotation:-15,
    viewMode:'3D',//开启3D视图,默认为关闭
    buildingAnimation:true,//楼块出现是否带动画

    expandZoomRange:true,
    zooms:[3,20],
    center:[116.333926,39.997245]
});

```

#### 3.图层

```
标准图层 TileLayer
卫星图层 TileLayer.Satellite
路网图层 TileLayer.RoadNet
实时交通图层 TileLayer.Traffic
楼块图层 Buildings
室内地图 IndoorMap
ps：WMS/WMTS地图服务必须符合OGC标准的支持EPSG3857坐标系统，否则传的参数进去找不到
此时可以使用TileLayer的getTileUrl拼接传入的参数
```
#### 4.控件

控件引用的时候不需要像插件那样在引用的key值后写入插件名
https://lbs.amap.com/api/jsapi-v2/example/map-componets/map-with-function-control/

```
// 添加控件按钮 控制旋转 倾斜角度
map.addControl(new AMap.ControlBar({
    showZoomBar:false, // 是否显示缩放按钮
    showControlButton:true, // 是否显示控制旋转 倾斜角度按钮
    position:{
      right:'10px',
      top:'10px'
    } // 控件显示的位置
}))
```

#### 5.方法

```
//构造一个地理坐标对象，lng、lat分别代表经度、纬度值;
AMap.LngLat(lng:Number,lat:Number,noAutofix:bool)
var position = [116, 39]; //简写 经度在前 纬度在后

//矩形范围的构造函数.
//参数southWest、northEast分别代表地物对象西南角经纬度和东北角经纬度值
AMap.Bounds(southWest:LngLat, northEast:LngLat)

//根据地图上添加的覆盖物分布情况，自动缩放地图到合适的视野级别，参数可选
map.setFitView();
```
##### 坐标系转换

```
var pixel = new AMap.Pixel(x,y); // 参数为x,y 容器像素坐标
var lnglat = map.containerToLngLat(pixel); // 得到转换的经纬度

var lnglat = new AMap.LngLat(lng, lat);// 参数为经度，纬度
var pixel = map.lnglatTocontainer(lnglat); // 得到转换的容器像素坐标

var lnglat = new AMap.LngLat(lng, lat);// 参数为经度，纬度
var pixel = map.lnglatToPixel(lnglat,zoom); // 参数为经纬度和缩放层级。得到转换的平面坐标
pixel.x = parseInt(pixel.x); // 取整
pixel.y = parseInt(pixel.y);

var pixel = new AMap.Pixel(x,y); // 参数为平面坐标x,y
var lnglat = map.pixelToLngLat(pixel,zoom); // 参数为平面坐标和缩放层级 得到转换的经纬度

// 经纬度转换为三维坐标
var lnglat = new AMap.LngLat(lng, lat);

//经纬度转换为三维坐标系下的 XY 坐标 map3D.lngLatToGeodeticCoord
var pixel = map.lngLatToGeodeticCoord(lnglat);

pixel.x = parseInt(pixel.x);
pixel.y = parseInt(pixel.y);

// 三维坐标系下的 XY 坐标转换为经纬度 map3D.geodeticCoordToLngLat
var pixel = new AMap.Pixel(x,y);   
var lnglat = map.geodeticCoordToLngLat(pixel);
```

#### 6.事件与插件示例

##### 获取鼠标点击经纬度

```
 map.on('click', function(e) {
        document.getElementById("lnglat").value = e.lnglat.getLng() + ',' + e.lnglat.getLat()
    });
```

##### 输入自动提示 选择自动定位 Autocomplete插件

```
// 引入Autocomplete插件
<script src="https://webapi.amap.com/maps?v=1.4.12&key=您申请的key值&plugin=AMap.Autocomplete"></script>

<input type="text"  id="tipinput">

var map = new AMap.Map('container', {
	resizeEnable: true, //是否监控地图容器尺寸变化
});
var auto = new AMap.Autocomplete({
    input: "tipinput"
});
AMap.event.addListener(auto, "select", select);
  function select(e) {
    console.log(e.poi);
    if (e.poi && e.poi.location) {
        map.setZoom(15);
        map.setCenter(e.poi.location);
    }
}
```

#####  拖拽事件 

```
//地图和覆盖物的拖拽事件不同
//地图拖拽相关事件
map.on('dragstart', showInfoDragstart);：拖拽开始
map.on('dragging', showInfoDragging);：拖拽中
map.on('dragend', showInfoDragend);：拖拽结束
map.off('dragstart', showInfoDragstart);
map.off('dragging', showInfoDragging);
map.off('dragend', showInfoDragend);

//覆盖物拖拽事件
// ps需要在初始化的时候添加属性draggable: true
marker.on('dragging', showInfoM);
circle.on('dragging', showInfoC);
polygon.on('dragging', showInfoP);

marker.off('dragging', showInfoM);
circle.off('dragging', showInfoC);
polygon.off('dragging', showInfoP);

```

#####  自定义事件 

```
//通过模拟click点击事件打开信息窗体
var map = new AMap.Map("container", {
    resizeEnable: true,
    zoom: 13
});
var clickHandler = function(e) {
    log.success("您模拟触发了地图click事件!");
    new AMap.InfoWindow({
        content:'模拟事件触发',
    }).open(map,e.lnglat)
};
// 
map.on('click', clickHandler);
map.on('complete', function() { // 在地图加载完成时模拟了鼠标点击事件
    setTimeout(function(){
        // 模拟触发地图click事件
        map.emit('click',{
            lnglat : map.getCenter()
        });
    },2000)
})
```



#### 7.热点与信息窗体PlaceSearch插件

```

<script>
    var map = new AMap.Map('container', {
        resizeEnable: true,
        center: [116.397428, 39.90923],
        zoom: 13,
        isHotspot: true
    });
    
    var placeSearch = new AMap.PlaceSearch();  //构造地点查询类
    var infoWindow=new AMap.AdvancedInfoWindow({});//高级信息窗体，整合了周边搜索、路线规划功能
    //hotspotover 鼠标滑过热点时触发
    map.on('hotspotover', function(result) {
    	//PlaceSearch.getDetails，根据POIID获取某个POI的详细信息。 传入id
        placeSearch.getDetails(result.id, function(status, result) {
            if (status === 'complete' && result.info === 'OK') {
                placeSearch_CallBack(result);
            }
        });
    });
    //回调函数
    function placeSearch_CallBack(data) { //infoWindow.open(map, result.lnglat);
        var poiArr = data.poiList.pois;
        var location = poiArr[0].location;
        infoWindow.setContent(createContent(poiArr[0]));
        infoWindow.open(map,location);
    }
    function createContent(poi) {  //信息窗体内容
        var s = [];
        s.push('<div class="info-title">'+poi.name+'</div><div class="info-content">'+"地址：" + poi.address);
        s.push("电话：" + poi.tel);
        s.push("类型：" + poi.type);
        s.push('<div>');
        return s.join("<br>"); // 返回一个html字符串
    }
</script>
```



### 框架 ant-design 搭配 es6+学习

1.如果colums里出现 scopedSlots: { customRender: 'xx' }, 则template里有相应的slot=“xx”

即把template里写好的slot插槽到指定的数据项里

2.如果colums里customRender: text => formatPrice(text)

customRender里有3个参数 参数分别为当前行的值，当前行数据，行索引  text, record, index 

template里会有相应的 slot-scope="tex，xx,  xx"三个参数去传入相应数据

3.ant-design避坑指南

 https://www.cnblogs.com/jlliu/p/11165741.html 

4.环境

vue-cli3默认安装了@vue/cli-service,@vue/cli-plugin-babel,@vue/cli-plugin-eslint插件，依赖包及webpack相关配置

[@vue/cli-plugin-babel](https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue-docs-zh-cn/blob/master/vue-cli-plugin-babel/README.md) 文档里提到了集成了 [@vue/babel-preset-app](https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue-docs-zh-cn/blob/master/vue-babel-preset-app/README.md)，[@vue/babel-preset-app](https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue-docs-zh-cn/blob/master/vue-babel-preset-app/README.md) 文档里提到了集成了 babel-preset-env 这个 babel preset，`preset-env` 会基于你的浏览器目标自动决定要运用的语法转换和 polyfill

 useBuiltIns:"entry"会根据浏览器版本的支持，将 polyfill 按需引入。你要在target里指明你的目标浏览器版本 

bable7升级指南

 https://segmentfault.com/a/1190000020307610 

5.

| mapPropsToFields | 把父组件的属性映射到表单项上（如：把 Redux store 中的值读出），需要对返回值中的表单域数据用 [`Form.createFormField`](https://www.antdv.com/components/form-cn/#Form.createFormField) 标记，如果使用$form.createForm 创建收集器，你可以将任何数据映射到 Field 中，不受父组件约束 | (props) => ({ [fieldName]: FormField { value } }) |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------- |
|                  |                                                              |                                                   |

### nginx相关

1.常见命令
powerShell（open）shift + 右键

查看nginx配置成功否 ng -> tab   +  -t

重启nginx  ng -> tab   +   -s reload

2.nginx配置iframe跨域

```
location ^~ /publicity_wssslj {
	proxy_pass         http://www.xjws.gov.cn; 
	proxy_hide_header X-Frame-Options;
}
location ^~ /Content {
     proxy_pass         http://www.xjws.gov.cn; 
}
```

### 编辑器vscode

想输出一个div class为list，写div.list

### 前端调试

#### Rendering 

Chrome渲染分析工具 Rendering 

按F12调出开发者工具，然后按“ESC”调出Rendering界面。

5个选项的意思如下：

- 1、Show paint rectangles 显示绘制矩形
- 2、Show composited layer borders 显示层的组合边界（注：蓝色的栅格表示的是分块）
- 3、Show FPS meter 显示FPS帧频
- 4、Enable continuous page repainting 开启持续绘制模式 并 检测页面绘制时间
- 5、Show potential scroll bottlenecks 显示潜在的滚动瓶颈

timing 16.66s

 栅栏，分别代表页面中的**网络和HTML解析**(蓝色)，**JavaScript**(黄色)，**样式重计算和布局**(紫色)以及**绘画和合成**(绿色)事件。重绘是浏览器事件，是为响应诸如窗口大小改变或者滚动之类的视觉变化而调用的 
## 一.数据结构和算法 

### 1.算法复杂度

- 程序执行的时候需要的计算量--cpu(时间复杂度)和内存空间(空间复杂度)
- 复杂度是数量级，不是具体的数字
- 一般针对一个具体的算法，而非整个系统
- 用O(...)表示，内部是一个函数表达式

#### 1.1时间复杂度

如下图，一般时间复杂度达到o(n²) 基本不可用

![1658668179120](E:\learning\suanfaImg\算法复杂度.png)

- o(1) 是可数的，与输入量无关，一次就够
- o(logn) logn随着输入量的增加，计算趋于平缓
- o(n) 输入量是多少，n是多少，和传输的数据量一样（ ex:循环一次）
- o(n²) 数据量的平方，ex:循环嵌套循环
- o(nlogn) 数据量×数据量的对数 ex:循环嵌套二分法

#### 1.2空间复杂度

前端: 重时间轻空间，类似时间复杂度

o(n) ，ex：在某数组循环中，定义另一个空数组，并赋值/push给这个新数组

#### 1.3题目案例

##### 将一个数组旋转k步

思路1：把数组末尾pop再unshift

![1658687176201](E:\learning\suanfaImg\数组旋转k思路1.png)

思路2：把数组按k值进行拆分，然后contact到一起

![1658687228907](E:\learning\suanfaImg\数组旋转k思路2.png)

###### 单元测试

test文件

![1658686477966](E:\learning\suanfaImg\数组旋转k单元测试1.png)![1658686870709](E:\learning\suanfaImg\数组旋转k单元测试2.png)

ps：k不是数字的情况: 取绝对值 => k对length取余,  表达式为NaN，然后for循环里，NaN做任何表达式返回都是false，因此i<NaN为false循环不执行

###### 性能分析

![1658774916424](E:\learning\suanfaImg\数组旋转k性能测试.png)

思路1：时间复杂度o(n²) , 空间复杂度o(1) 

​	为什么是o(n²) ，数组是一个有序数组，连续的内存空间，unshift非常慢，插到最前面，后面的空间都要依次移动，同理：shift、splice都很慢，本身时间复杂度就为o(n) ，这也是为什么会改变原数组

​	pop、push很快，只在末尾操作

思路2：时间复杂度o(1) , 空间复杂度o(n) 

​	slice不改变原数组，函数的时间复杂度为o(1) 

总结：重时间轻空间，选思路2

扩展：思路3

![1658860784563](E:\learning\suanfaImg\数组旋转k思路3.png)

不推荐，比复杂度更重要的是代码清晰易读

##### 

### 2.栈

- 先进后出
- 压栈：入栈
- API：push、pop、length
- 相关知识点：堆、队列

![1658861273748](E:\learning\suanfaImg\栈.png)

#### 2.1逻辑结构vs物理结构

栈vs数组：数组可以表示栈，但他们之间没有什么关系

栈是一种逻辑结构，物理模型（抽象），不管如何实现，不受语言的限制

数组是物理结构，真正的功能实现，受限于编程语言

#### 2.3题目案例

##### 判断一个字符串是否括号匹配  

![1658861013808](E:\learning\suanfaImg\判断一个字符串是否括号匹配 题目.png)

思路

![1658861775214](E:\learning\suanfaImg\判断一个字符串是否括号匹配思路.png)

###### 单元测试

![1658862941518](E:\learning\suanfaImg\判断一个字符串是否括号匹配单元测试1.png)

###### 性能分析

时间复杂度o(n) , 空间复杂度o(n) 

虽然include本身时间复杂度为o(n) ，但是这里的leftSymbols和rightSymbols是固定的，与输入的字符串str量无关，总的时间复杂度o(n) 
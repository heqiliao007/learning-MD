## 一.工具量化分析

### 1.性能指标和行业标准

加载：
network瀑布图
    浅灰：查询中
    深灰：停滞，代理转发，请求发送
    橙色：初始连接------建立TCP连接
    绿色：等待中-----TTFB，考虑是否需要使用CDN
    	      深绿色------DNS查询， 将域名转换成IP地址
    蓝色：内容下载-----资源下载时间
Waiting (TTFB) :资源发出请求出去到回来的时间
HAR存储：右键：save as HAR（web性能格式统一标准）
	如何解析HAR格式文件：network里有个上传箭头，上传即可
速度指数(Speed Index)：4s
页面加载时间finish
lighthouse生成报告（google插件形式）：
	First Contentful Paint：以颜色区分，绿色代表非常好
	首屏时间：可以查看白屏等待时间（能知道渐进式应用的多少）
	Speed Index(速度指数)标准：<4s 
	
交互响应：
流畅的动画帧数1s达到60帧
	ctrl+shift+p：输入frame，选择fps 查看帧数是否达到60fps
异步请求时间：1s内+loading动画

### 2.RAIL测量模型--黄金指南

以用户为中心的性能模型 

- Response 响应

	事件处理(留给我们自己的处理时间)最好在50ms内完成，用户的输入到响应的时间不超过		100ms给用户反馈

- Animation 动画
	10ms内产生一帧，每一帧的时间在16ms左右，但浏览器需要用6ms来渲染每一帧

- Idle 最大化空闲时间
	增大50ms内响应用户输入的几率，前端不应该进行大量数据的运算

- Load 资源加载
	 传输内容到页面可交互的时间不超过5秒

分析RAIL用的工具
-	 Chrome DevTools 开发调试、性能评测
-	 Lighthouse 整体质量评估
-	 WebPageTest 多测试地点，全面性能报告

### 3.WebPageTest 

 https://webpagetest.org/ 

Browser：浏览器
Connection：网络连接
Number of Tests to Run：测试轮数
Repeat View：First View and Repeat View：第一次和后面次数的对比
Capture Video：录屏

报告：
waterfall chart 请求瀑布图
first view 首次访问
repeat view 二次访问

如何本地部署WebPageTest ？
 [https://cpselvis.github.io/2018/11/%E5%9F%BA%E4%BA%8EDocker%E6%90%AD%E5%BB%BAWebpagetest%E6%9C%8D%E5%8A%A1/](https://cpselvis.github.io/2018/11/基于Docker搭建Webpagetest服务/)  

### 4.LightHouse

以命令行的方式：
npm i -g lighthouse
lighthouse http://xxxxxx 生成一个性能测试报告

设置可选择设备类型等

报告Metrics（指标）：
First Contentful Paint 代表文档中内容元素（文本、图像、Canvas，或者 SVG）首次渲染的时间
Speed Index 速度指数
Largest Contentful Paint 用于监控网页可视区内“绘制面积”最大的元素开始呈现在屏幕上的时间点
Time to Interactive 用户可交互时间（用户多久可以和系统交互，与首屏有关）
Total Blocking Time(TBT)总阻塞时间。用来量化加载的响应能力，累积主线程被阻塞并会影响用户操作反馈的总时间

Opportunities建议
	如何看阻塞的js是不是必要加载的：ctrl+shift+p调出命令行，输入block，选择shouw request blocking，点击+，比如输入log*.js，log.js相关的就不会执行了

Diagnostics诊断

### 5.Chrome DevTools【最大法宝】

①关于size：资源压缩
上面的size代表网络传输过去size的大小
下面的size代表所加载资源实际的大小
两者可以不同，资源压缩后，减少传输大小

②performance：性能分析
刷新或者点击小圆点重新记录，性能分析
main：主线程
	拖动需要点击住再进行拖动
timings：关键的时间节点

③network
性能测评时disable-cache 取消掉，需要知道设置的缓存在第二次请求及后面请求有没有生效
throttling可以自定义设置吞吐量

④more tools
rendering渲染
	paint flashing 滚动时产生的重绘
	fps meter 监测动画帧数
performance monitor性能检测
	可以监测dom节点数，cpu、js堆占用，布局、样式重绘计算

### 6.常用的性能测量APIs--动态测量

浏览器核心工作轴/ 从输入 url 到页面呈现，浏览器核心工作过程  https://blog.csdn.net/weixin_44135121/article/details/103952234 

**第 1 步 开始计时**
startTime：记录开始时间。

**第 2 步 重定向**
redirectStart：重定向开始时间。
redirectEnd：重定向结束时间。

**第 3 步 浏览器与服务器连接**
fetchStart：浏览器发起 HTTP 请求时间。
domainLookupStart：DNS 查询开始时间。
domainLookupEnd：DNS 查询结束时间。
connectStart：TCP 连接开始时间。
connectEnd：TCP 连接结束时间。

**第 4 步 浏览器与服务器数据交互**
secureConnectionStart：浏览器跟服务器建立安全连接的时间。
requestStart：浏览器向服务器开始发送数据的时间。
responseStart：服务器向浏览器开始发送数据的时间。
responseEnd：服务器向浏览器结束发送数据的时间。

**第 5 步 浏览器 DOM 解析**
domLoading：DOM 开始解析的时间。
domInteractive：DOM 解析完成，开始加载内嵌资源的时间。
domContentLoadedEventStart：需要被执行的脚本已经被解析的时间。
domContentLoadedEventEnd：需要立即执行的脚本已经被执行的时间。
domComplete：文档解析完毕的时间。

补充： *loadEventStart*和loadEventEnd分别代表onload事件触发和结束的时间节点 

```
window.addEventListener('load', function() {
    //performance.getEntries() 方法可以查询所有资源的耗时，performance.getEntriesByType可以根据资源类型来查	   //看某种类型的资源耗时
    let t = performance.getEntriesByType('navigation')[0]
    
    //tti：Time to Interactive用户可交互时间
    let tti = t.domInteractive - t.fetchStart
});

//通过api去发现程序中的长任务
//通过performance得到所有的的long task任务
let observer = new PerformanceObserver((list)=>{
	for(const entry of list.getEntries()){
		//通过entry的duration可以看到时间
		console.log(entry)
	}
})
//监听longtask这种类型
observer.observe({entryTypes: ['longtask']})

//知道用户显示状态 ui api
let vEvent = 'visibilitychange';
if(document.webkitHidden != undefined){
	// webkit 事件名称
	vEvent = 'webkitvisibilitychange'
}
function visibilityChanged(){
	if(document.hidden || document.webkitHidden){
		console.log('web page is hidden')
	}else{
		//页面可见
		console.log('web page is visible')
	}
}
window.addEventListener('vEvent', visibilityChanged, false);

//知道网络状态network API
//在控制台输出
let connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection
let type = connection.effectiveType
function updateConnectionStatus(){
	console.log('connection type changed from'+ type + 'to' + connection.effectiveType)
}
window.addEventListener('change', updateConnectionStatus);
//随便调整network的吞吐可以看到变化

//关键时间节点算法
1、DNS查询耗时
	t.domainLookupEnd - t.domainLookupStart || 0;
2、TCP建立连接耗时
	t.connectEnd - t.connectStart;
3、SSL安全链接耗时
	t.connectEnd - t.secureConnectionStart;
4、TTFB网络请求耗时
	t.responseStart - t.requestStart;
5、数据传输耗时
	t.responseEnd - t.responseStart
6、Dom结构解析耗时
    body完成,header中写的js(不含defer属性)会影响该值
    t.domInteractive - t.responseEnd;
7、资源加载耗时
	t.loadEventStart - t.domContentLoadedEventEnd 
8、first byte时间/首包时间
	HTTP通讯响应时间，自你发送完请求后，到服务器返回给你第一个信息中间的耗时
	t.responseStart - t.domainLookupStart
9、白屏时间
	t.responseEnd - t.fetchStart
10、首次可交互时间
	 t.domInteractive - t.fetchStart
11、dom ready时间
	t.domContentLoadEventEnd - t.fetchStart
12、页面完全加载时间
	t.loadEventStart - t.fetchStart
13、http头部大小
	t.transferSize - t.encodedBodySize
14、重定向次数
	performance.navigation.redirectCount
15、首屏加载时间
	domComplete - navigationStart
```




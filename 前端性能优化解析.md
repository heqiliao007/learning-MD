## 一.工具量化分析

### 1.性能指标和行业标准

加载：
network瀑布图
    浅灰：查询中
    深灰：停滞，代理转发，请求发送
    橙色：初始连接------建立TCP连接
    绿色：等待中-----TTFB，考虑是否需要使用CDN
    	      深绿色------DNS查询， 将域名转换成IP地址
    蓝色：内容下载-----资源下载时间
Waiting (TTFB) :资源发出请求出去到回来的时间
HAR存储：右键：save as HAR（web性能格式统一标准）
	如何解析HAR格式文件：network里有个上传箭头，上传即可
速度指数(Speed Index)：4s
页面加载时间finish
lighthouse生成报告（google插件形式）：
	First Contentful Paint：以颜色区分，绿色代表非常好
	首屏时间：可以查看白屏等待时间（能知道渐进式应用的多少）
	Speed Index(速度指数)标准：<4s 
	
交互响应：
流畅的动画帧数1s达到60帧
	ctrl+shift+p：输入frame，选择fps 查看帧数是否达到60fps
异步请求时间：1s内+loading动画

### 2.RAIL测量模型--黄金指南

以用户为中心的性能模型 

- Response 响应

	事件处理(留给我们自己的处理时间)最好在50ms内完成，用户的输入到响应的时间不超过		100ms给用户反馈

- Animation 动画
	10ms内产生一帧，每一帧的时间在16ms左右，但浏览器需要用6ms来渲染每一帧

- Idle 最大化空闲时间
	增大50ms内响应用户输入的几率，前端不应该进行大量数据的运算

- Load 资源加载
	 传输内容到页面可交互的时间不超过5秒

分析RAIL用的工具
-	 Chrome DevTools 开发调试、性能评测
-	 Lighthouse 整体质量评估
-	 WebPageTest 多测试地点，全面性能报告

### 3.WebPageTest 

 https://webpagetest.org/ 

Browser：浏览器
Connection：网络连接
Number of Tests to Run：测试轮数
Repeat View：First View and Repeat View：第一次和后面次数的对比
Capture Video：录屏

报告：
waterfall chart 请求瀑布图
first view 首次访问
repeat view 二次访问

如何本地部署WebPageTest ？
 [https://cpselvis.github.io/2018/11/%E5%9F%BA%E4%BA%8EDocker%E6%90%AD%E5%BB%BAWebpagetest%E6%9C%8D%E5%8A%A1/](https://cpselvis.github.io/2018/11/基于Docker搭建Webpagetest服务/)  

### 4.LightHouse

以命令行的方式：
npm i -g lighthouse
lighthouse http://xxxxxx 生成一个性能测试报告

设置可选择设备类型等

报告Metrics（指标）：
First Contentful Paint 代表文档中内容元素（文本、图像、Canvas，或者 SVG）首次渲染的时间
Speed Index 速度指数
Largest Contentful Paint 用于监控网页可视区内“绘制面积”最大的元素开始呈现在屏幕上的时间点
Time to Interactive 用户可交互时间（用户多久可以和系统交互，与首屏有关）
Total Blocking Time(TBT)总阻塞时间。用来量化加载的响应能力，累积主线程被阻塞并会影响用户操作反馈的总时间

Opportunities建议
	如何看阻塞的js是不是必要加载的：ctrl+shift+p调出命令行，输入block，选择shouw request blocking，点击+，比如输入log*.js，log.js相关的就不会执行了

Diagnostics诊断

### 5.Chrome DevTools【最大法宝】

①关于size：资源压缩
上面的size代表网络传输过去size的大小
下面的size代表所加载资源实际的大小
两者可以不同，资源压缩后，减少传输大小

②performance：性能分析
刷新或者点击小圆点重新记录，性能分析
main：主线程
	拖动需要点击住再进行拖动
timings：关键的时间节点

③network
性能测评时disable-cache 取消掉，需要知道设置的缓存在第二次请求及后面请求有没有生效
throttling可以自定义设置吞吐量

④more tools
rendering渲染
	paint flashing 滚动时产生的重绘（重绘元素变为绿色）
	fps meter 监测动画帧数
performance monitor性能检测
	可以监测dom节点数，cpu、js堆占用，布局、样式重绘计算

### 6.常用的性能测量APIs--动态测量

浏览器核心工作轴/ 从输入 url 到页面呈现，浏览器核心工作过程  https://blog.csdn.net/weixin_44135121/article/details/103952234 

**第 1 步 开始计时**
startTime：记录开始时间。

**第 2 步 重定向**
redirectStart：重定向开始时间。
redirectEnd：重定向结束时间。

**第 3 步 浏览器与服务器连接**
fetchStart：浏览器发起 HTTP 请求时间。
domainLookupStart：DNS 查询开始时间。
domainLookupEnd：DNS 查询结束时间。
connectStart：TCP 连接开始时间。
connectEnd：TCP 连接结束时间。

**第 4 步 浏览器与服务器数据交互**
secureConnectionStart：浏览器跟服务器建立安全连接的时间。
requestStart：浏览器向服务器开始发送数据的时间。
responseStart：服务器向浏览器开始发送数据的时间。
responseEnd：服务器向浏览器结束发送数据的时间。

**第 5 步 浏览器 DOM 解析**
domLoading：DOM 开始解析的时间。
domInteractive：DOM 解析完成，开始加载内嵌资源的时间。
domContentLoadedEventStart：需要被执行的脚本已经被解析的时间。
domContentLoadedEventEnd：需要立即执行的脚本已经被执行的时间。
domComplete：文档解析完毕的时间。

补充： *loadEventStart*和loadEventEnd分别代表onload事件触发和结束的时间节点 

#### API实例

 https://blog.csdn.net/qiwoo_weekly/article/details/102791689 

https://segmentfault.com/a/1190000014479800

https://blog.csdn.net/weixin_33895475/article/details/87950661

```
window.addEventListener('load', function() {
    //performance.getEntries() 方法可以查询所有资源的耗时，performance.getEntriesByType可以根据资源类型来查	   //看某种类型的资源耗时
    let t = performance.getEntriesByType('navigation')[0]
    
    //tti：Time to Interactive用户可交互时间
    let tti = t.domInteractive - t.fetchStart
});

//通过api去发现程序中的长任务
//通过performance得到所有的的long task任务
let observer = new PerformanceObserver((list)=>{
	for(const entry of list.getEntries()){
		//通过entry的duration可以看到时间
		console.log(entry)
	}
})
//监听longtask这种类型
observer.observe({entryTypes: ['longtask']})

//知道用户显示状态 ui api
let vEvent = 'visibilitychange';
if(document.webkitHidden != undefined){
	// webkit 事件名称
	vEvent = 'webkitvisibilitychange'
}
function visibilityChanged(){
	if(document.hidden || document.webkitHidden){
		console.log('web page is hidden')
	}else{
		//页面可见
		console.log('web page is visible')
	}
}
window.addEventListener('vEvent', visibilityChanged, false);

//知道网络状态network API
//在控制台输出
let connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection
let type = connection.effectiveType
function updateConnectionStatus(){
	console.log('connection type changed from'+ type + 'to' + connection.effectiveType)
}
window.addEventListener('change', updateConnectionStatus);
//随便调整network的吞吐可以看到变化

//关键时间节点算法
1、DNS查询耗时
	t.domainLookupEnd - t.domainLookupStart || 0;
2、TCP建立连接耗时
	t.connectEnd - t.connectStart;
3、SSL安全链接耗时
	t.connectEnd - t.secureConnectionStart;
4、TTFB网络请求耗时
	t.responseStart - t.requestStart;
5、数据传输耗时
	t.responseEnd - t.responseStart
6、Dom结构解析耗时
    body完成,header中写的js(不含defer属性)会影响该值
    t.domInteractive - t.responseEnd;
7、资源加载耗时
	t.loadEventStart - t.domContentLoadedEventEnd 
8、first byte时间/首包时间
	HTTP通讯响应时间，自你发送完请求后，到服务器返回给你第一个信息中间的耗时
	t.responseStart - t.domainLookupStart
9、白屏时间
	t.responseEnd - t.fetchStart
10、首次可交互时间
	 t.domInteractive - t.fetchStart
11、dom ready时间
	t.domContentLoadEventEnd - t.fetchStart
12、页面完全加载时间
	t.loadEventStart - t.fetchStart
13、http头部大小
	t.transferSize - t.encodedBodySize
14、重定向次数
	performance.navigation.redirectCount
15、首屏加载时间
	domComplete - navigationStart
```

## 二.渲染优化

### 1.关键渲染路径

浏览器渲染原理：
读取html，css文本，构建DOM树。（DOM ，CSSDOM）- DOMtree 

关键渲染路径：5个步骤
javascript（js或者css动画触发视觉变化） - style（样式计算，css改变） - Layout（布局）- Paint（绘制）- Composite（合层）

### 2.回流与重绘，避免布局抖动

#### 2.1区分布局绘制、回流

布局关心的是位置和大小。（如css：height，offset改变位置，大小---几何信息）
如果只是更改background，opcity，不需要Layout（布局），只需Paint（重绘） 
首次加载叫布局，再次叫回流

#### 2.2 影响回流的操作 

- 　添加/删除 元素，
- 　操作styles，display：none。
- 　offsetLeft，offsetTop ，scrollTop，clientWidth。使用这些属性，会引起强制布局更新。
- 移动元素位置
- 　修改浏览器大小，字体大小

#### 2.3  回流不可避免的情况 - 布局抖动（layout thrashing） 

 连续的读（获取offset等）写（赋值给宽高等）操作，会引起强制的布局更新，强制布局更新会造成页面抖动
 如何查看：
     通过devtools，performance 可以查看回流的过程，在onLoad后的timing（长任务有三角标志），Layout--forceReflow
 解决布局抖动方案：
	 避免回流，读写分离
	 批量的读 (var wid = element.clientWidth;），批量的写入 (element.style.width = wid + 'px';) 

#### 2.4使用FastDom 解决布局抖动(流行)

 https://github.com/wilsonpage/fastdom 

```
const fn = (param)=>{
	fastdom.measure(() => {
      //measure读操作
      fastdom.mutate(() => {
          //mutate写操作
          console.log('mutate');
        });
    });
}

window.requestAnimationFrame(fn)
```

#### 2.5复合线程(compositor thread)与图层

  复合线程做了什么

- 将页面拆分图层进行绘制再进行复合
- 利用DevTools了解网页的图层拆分情况（如何看图层）---frames---layers
- 哪些样式仅影响复合

哪些样式仅影响复合（避免重绘 ）

- transform:translate/scale(代替width、height)、ratotion
- opacity

#### 2.6减少重绘

利用DevTools：rendering--paint flashing识别paint重绘图层

利用will-change创建新的图层（必须考虑数量和必要性）

- 如果静态图层和动画图层在同一层级的时候，会产生抖动，这时候需要使用will-change，改变其效果

- 移动端尽量少用，因为会引起cpu内存问题，pc端适量去用，最好在优化后可以在动画完成取消优化，如果动画连续且使用的不多，可以使用will-change

```
{
	https://www.cnblogs.com/yuzhongwusan/p/4186405.html
	// `will-change` 为web开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作 
	//浏览器知道元素被提取到单独的图层
	will-change: transform;
}
```

#### 2.7高频事件防抖+raf

scorll、pointermove（鼠标滑动）、mousemove、touch，卡顿问题

帧数生命周期：raf在布局layout、paint之前触发，requestAnimationFrame属于raf

```
//如果某个函数会改变网页的布局，一般就放在window.requestAnimationFrame()里面执行，这样可以节省系统资源，使得网页效果更加平滑。因为慢速设备会用较慢的速率重流和重绘，而速度更快的设备会有更快的速率。
//window.requestAnimationFrame()则是推迟到浏览器下一次重流时执行，执行完才会进行下一次重绘。重绘通常是 16ms 执行一次
window.requestAnimationFrame(callback)//该方法接受一个回调函数作为参数

var ticking = false;
window.addEventListener('pointermove', e => {
	let pos = e.clientX;
	if(ticking) return false;
	ticking = true;
	window.requestAnimationFrame(()=>{
	
		//change width function
		
		ticking = false; //事件执行后可以再触发下一个requestAnimationFrame
	})
})


//underscore中
{
	// 第六版
    function debounce(func, wait, immediate) {

        var timeout, result;

        var debounced = function () {
            var context = this;
            var args = arguments;

            if (timeout) clearTimeout(timeout);
            if (immediate) {
                // 如果已经执行过，不再执行
                var callNow = !timeout;
                timeout = setTimeout(function(){
                    timeout = null;
                }, wait)
                if (callNow) result = func.apply(context, args)
            }
            else {
                timeout = setTimeout(function(){
                    result = func.apply(context, args)
                }, wait);
            }
            return result;
        };

        debounced.cancel = function() {
            clearTimeout(timeout);
            timeout = null;
        };

        return debounced;
    }
    
    //调用
    let debouncedFn = debounce(fn, 1000, false)//注意fn不能加括号
 
    window.addEventListener('resize', async () => {
      let val
      try {
        val = await debouncedFn(4)
      } catch (err) {
        console.error(err)
      }
      console.log(`原函数返回值为${val}`)
    }, false)

}
```

#### 2.8时间调度实现（react）（rIC）

帧数生命周期：requestIdecallback在布局layout、paint之后触发， 将在浏览器的空闲时段内调用的函数排队 
你可以在空闲回调函数中调用requestIdleCallback() （rIC），以便在下一次通过事件循环之前调度另一个回调 

一些低优先级的任务可使用 `requestIdleCallback` 等浏览器不忙的时候来执行，同时因为时间有限，它所执行的任务应该尽量是能够量化，细分的微任务（micro task）

因为它发生在一帧的最后，此时页面布局已经完成，**所以不建议在 `requestIdleCallback` 里再操作 DOM**，这样会导致页面再次重绘。**DOM 操作建议在 rAF 中进行**。同时，操作 DOM 所需要的耗时是不确定的，因为会导致重新计算布局和视图的绘制，所以这类操作不具备可预测性。

**Promise 也不建议在这里面进行**，因为 Promise 的回调属性 Event loop 中优先级较高的一种微任务，会在 requestIdleCallback结束时立即执行，不管此时是否还有富余的时间，这样有很大可能会让一帧超过 16 ms。

#### 一些概念难点

https://segmentfault.com/a/1190000019154514

https://time.geekbang.org/column/article/169468

## 三.代码优化 (缩短js解析时间)

### 1.代码拆分，按需加载（code splitting）

 当前访问路径需要哪些资源就加载哪些资源，不需要的我们给它延迟，访问的时候再去加载。达到减少加载js的目的 

### 2.代码减重（tree shaking）

 只是引用了loadsh里面的一个函数，就可以把这一个函数打包到bundle文件中 

### 3.减少主线程工作量

- 避免长任务

  任务时间越长，占据的阻塞越久 

- 避免超过1kb的行间脚本

  写行间脚本可能是为了加快首屏的渲染。剩下的再通过web文件进行加载。

  对于行间脚本，浏览器不能进行优化

- 使用raf和ric进行时间调度

### 4.V8引擎解析原理

node用v8引擎
v8会对代码进行优化，发现优化的不行了呢，还会反向优化，就会浪费很多时间，代码层面避免反优化
了解V8做了哪些优化： node  --trace-opt  --trace-deopt de-opt.js。

#### **4.1抽象语法树**

源码=》抽象语法树=》字节码Bytecode=》机器码

编译过程会进行优化

运行时可能会发生反优化

```
performance.mark('start') //性能测量标记
add = (a,b) =>  a + b

const num1 = 0
const num2 = 2

for(let i = 0; i < 1000000; i++) {
  add(num1,num2)
}

//add(num1,'1dsd')   // V8已经做了对于add的优化。如参数类型改变。所以要撤掉已做的优化，会造成一些延迟。反优化

for(let i = 0; i < 1000000; i++) {
  add(num1,num2)
}
performance.mark('end')

const observer = new PerformanceObserver(list => {
    console.log(list.getEntries()[0])
});
observer.observe({
    entryTypes: ['measure']
});
performance.measure('start', 'add', 'end');
```

### 5.v8优化机制

**脚本流**
检查超过30kb的脚本，就认为问价已经足够大，会单独开一个线程进行解析。

**字节码缓存**
经常使用的变量进行缓存

**懒解析**
主要针对于函数，先声明但是不解析

### 6.函数优化
懒解析的好处，如果不需要解析，那就不用在“堆”里面分配内存，不用为它创建一个语法树。可以提高我们加载js的一个整体的效率。
但是现实中，我们有时候还是需要我们的函数立即去执行的

#### **6.1函数解析方式**

**lazy parseing 懒解析 vs eager parseing 饥饿解析**

假如我们先进行懒解析，然后发现需要立即执行，还需要一个eager parseing,这样反而性能减半

**利用Optimize.js优化初次加载时间**

### 7.对象优化

- 以相同顺序初始化对象成员，避免隐藏类的调整

```
class RectArea { // HC0
  constructor(l, w) {
    this.l = l // HC1
    this.w = w // HC2
  }
}

const rect1 = new RectArea(3, 4)
const rect2 = new RectArea(5, 6)

// 隐藏类型无法复用
const car1 = {color: 'red'} // HC0
car1.seats = 4 // HC1
const car2 = {seats: 2} // HC2
car1.color = 'blue' // HC3
```

- 实例化后（初始化后） //In-object属性
  避免添加新属性 //Normal/Fast属性  存储在property store里 需要通过描述数组间接查找
- 尽量使用Array代替array-like（伪数组）对象（转换的代价更小）

```
//先把类数组转换成真实数组
es5： Array.prototype.slice.call(obj,0)

//我的思考：伪数组用arguments 对象是类数组的对象
//es6的 rest 参数在这里很有帮助。它们产生真正的数组，可以优雅的代替类似数组的对象 arguments
const logArgs = (...args) => {
  args.forEach((value, index) => {
    console.log(`${ index }: ${ value }`);
  });
};
logArgs('a', 'b', 'c');
// This logs '0: a', then '1: b', and finally '2: c'.
```

- 要避免读取超过数组的长度

```
function foo(array) {
  for(let i = 0; i <= array.length; i++) { // 越界比较 如果一个数组长度为3 array[3]为undefined
    if(array[i] > 1000){ // 1、造成undefined跟数字比较 2、沿原型链的查找
      //数组索引 3 超出范围，该属性不存在于数组本身上，因此 JavaScript 引擎必须执行相同的昂贵的原型链查找
      console.log(array[i]) // 业务上无效
    }
  }
}
```

- 避免元素类型转换

```
const array = [3, 2, 1] // PACKED_SMI_ELEMENTS
array.push(4.4) // PACKED_DOUBLE_ELEMENTS
array.push('x') //最后是PACKED_ELEMENTS
//推进4.4后v8之前对数组所做的优化就无效了 造成额外的开销

//稀疏数组 HOLEY
//如果删除某个元素 HOLLY_ELEMENTS
const array = new Array(3);
// 此时，数组是稀疏的，所以它被标记为 `HOLEY_SMI_ELEMENTS`

一旦数组被标记为有洞，它永远是有洞的 - 即使它被打包了！从那时起，数组上的任何操作都可能变慢。如果您计划在数组上执行大量操作，并且希望对这些操作进行优化，请避免在数组中创建空洞。V8 可以更有效地处理密集数组。
//我的思考：用es6的fill在数组初始化长度时配合使用
创建数组的一种更好的方法是使用字面量：
const array = ['a', 'b', 'c'];
// elements kind: PACKED_ELEMENTS
//如果您提前不知道元素的所有值，那么可以创建一个空数组，然后再 push 值
```

### 8.html优化

- 减少ifames 的使用
  ​	相当于多加了一个文档。父级文档要等它。

- 压缩空白符

- 避免深层次的嵌套
  	嵌套越深，遍历越慢（无用的div）

- 避免使用table布局
  	已经out！

- css/js尽量外链

- css尽量外联

  ​	什么时候写在行间 ------首屏优化

- 删除元素默认属性

- 语义化标签，方便浏览器做一些优化

  video配合source 多种格式去支持浏览器

- 有些标签可以不闭合

  ​	img、ol里的li

- html-minifier工具优化（webpack打包时自动集成）

- js放在下面，别阻塞dom加载

### 9.css对性能的优化

recalculate style
css读取虽然是自右向左读取, 现代浏览器对此优化已经很进步了

- 降低css的阻塞，用不到的到后面再进行加载。

  ​	比如除首屏外推迟加载

- 利用GPU进行完成动画，就是使用复合图层。

- 使用contain属性。
  	告诉浏览器，我和外面的没关系，只对我里面的元素进行更改，不用进行回流，布局的重新计算。

  ```
  li{
  	contain: content; 
  }
  ```

- font-display 属性
  	在页面上先展示文字，减轻文字闪动的问题

## 四.资源优化

### 1.资源的压缩与合并

#### **1.1目的**

减少http请求量
减小http请求资源的大小

#### 1.2怎么做

- html压缩
  ​	html-minifier自动化工具优化--github
      谷歌就没压缩，html上优化空间比较小,在其他方面做了大量的优化
- css压缩
	    使用npm上的工具,或者就使用html-minifier
  ​	js压缩与混淆，大部分时候都是使用webpack在构建时进行压缩。
- js压缩\css与js文件合并：
	    使用webpack对js构建时压缩
  	有的人认为合并比较好，有的人认为拆分比较好。在网络上加载比较快。
  	总结就是同一模块的小文件，可以这样(无冲突,服务相同)，因为现在都是渐进式加载(逐渐加载)。
	    单纯的为了优化，减少http请求，会影响用户体验, 并且可能影响其他地方。

### 2.图片格式优化

#### 2.1图片格式的选择

- ​	jpg 有损压缩 色彩好
  ​	生成jpg文件或者压缩优化工具github：imagemin
- ​	PNG 透明背景
  ​	场景：logo，纹理。但体积比较大 
  ​	工具：imagemin-pngquant
- ​    webP
  ​    谷歌新推出的图片格式
  ​    色彩上与JPG不相上下，但是压缩比更高。
  ​    支持webp的浏览器
  ​	注意兼容性
-    svg适合手机端

#### 2.1图片的优化方案

##### 	2.1.1懒加载
   原生实现：通过image的loading属性

```
<img loading="lazy" src=""/>
```

   第三方:vue-lazyload
   原生插件verlok/lazyload   yall.js

##### 2.1.2渐进式图片

  使用渐进式而不是 横扫描 ，一开始就看到图片全貌，逐渐变得清晰，用户体验更好
  方案：progressive-image、ImageMagick等

##### 2.1.3响应式图片

  image属性
  size预估的图片显示宽度
  srcset属性（需要不同尺寸的图片） src + 尺寸
  宽度描述w 像素密度描述x
  https://www.cnntt.com/archives/2635

#### 2.2字体优化

  字体下载未完成时，浏览器隐藏或自动降级，导致字体闪烁。
  Flash Of Invisible Text
  Flash Of Unstyled Text
  字体闪动不可避免

```
//1.控制字体加载行为
font-display:auto|block|swap|fallback|optional

// auto浏览器自动选择，无意义
// block 前3s不显示（白屏） 3s后如果没下载万显示默认字体，下载完后再替换
// swap 替换的字体 不会白屏，但是不好看 （用户一开始就能看到字体）需要的字体下载完成后再显示
// fallback 100ms 提前下载完，下载完之前不显示； 
// optional 为手机端优化，能够判断网速，如果网速不佳，使用默认字体，但是默认字体设置上，就不退了（一旦浏览器选择后就不更改）

//使用
@font-face{
    font-display: xx;
}

2.拆分不同字符集

3.ajax+base64 异步请求字体转码为base64，嵌入css
缺点：缓存问题
```

## 五.传输优化加载
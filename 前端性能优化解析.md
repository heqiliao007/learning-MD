## 一.工具量化分析

### 1.性能指标和行业标准

加载：
network瀑布图
    浅灰：查询中
    深灰：停滞，代理转发，请求发送
    橙色：初始连接------建立TCP连接
    绿色：等待中-----TTFB，考虑是否需要使用CDN
    	      深绿色------DNS查询， 将域名转换成IP地址
    蓝色：内容下载-----资源下载时间
Waiting (TTFB) :资源发出请求出去到回来的时间
HAR存储：右键：save as HAR（web性能格式统一标准）
	如何解析HAR格式文件：network里有个上传箭头，上传即可
速度指数(Speed Index)：4s
页面加载时间finish
lighthouse生成报告（google插件形式）：
	First Contentful Paint：以颜色区分，绿色代表非常好
	首屏时间：可以查看白屏等待时间（能知道渐进式应用的多少）
	Speed Index(速度指数)标准：<4s 
	
交互响应：
流畅的动画帧数1s达到60帧
	ctrl+shift+p：输入frame，选择fps 查看帧数是否达到60fps
异步请求时间：1s内+loading动画

### 2.RAIL测量模型--黄金指南

以用户为中心的性能模型 

- Response 响应

	事件处理(留给我们自己的处理时间)最好在50ms内完成，用户的输入到响应的时间不超过		100ms给用户反馈

- Animation 动画
	10ms内产生一帧，每一帧的时间在16ms左右，但浏览器需要用6ms来渲染每一帧

- Idle 最大化空闲时间
	增大50ms内响应用户输入的几率，前端不应该进行大量数据的运算

- Load 资源加载
	 传输内容到页面可交互的时间不超过5秒

分析RAIL用的工具
-	 Chrome DevTools 开发调试、性能评测
-	 Lighthouse 整体质量评估
-	 WebPageTest 多测试地点，全面性能报告

### 3.WebPageTest 

 https://webpagetest.org/ 

Browser：浏览器
Connection：网络连接
Number of Tests to Run：测试轮数
Repeat View：First View and Repeat View：第一次和后面次数的对比
Capture Video：录屏

报告：
waterfall chart 请求瀑布图
first view 首次访问
repeat view 二次访问

如何本地部署WebPageTest ？
 [https://cpselvis.github.io/2018/11/%E5%9F%BA%E4%BA%8EDocker%E6%90%AD%E5%BB%BAWebpagetest%E6%9C%8D%E5%8A%A1/](https://cpselvis.github.io/2018/11/基于Docker搭建Webpagetest服务/)  

### 4.LightHouse

以命令行的方式：
npm i -g lighthouse
lighthouse http://xxxxxx 生成一个性能测试报告

设置可选择设备类型等

报告Metrics（指标）：
First Contentful Paint 代表文档中内容元素（文本、图像、Canvas，或者 SVG）首次渲染的时间
Speed Index 速度指数
Largest Contentful Paint 用于监控网页可视区内“绘制面积”最大的元素开始呈现在屏幕上的时间点
Time to Interactive 用户可交互时间（用户多久可以和系统交互，与首屏有关）
Total Blocking Time(TBT)总阻塞时间。用来量化加载的响应能力，累积主线程被阻塞并会影响用户操作反馈的总时间

Opportunities建议
	如何看阻塞的js是不是必要加载的：ctrl+shift+p调出命令行，输入block，选择shouw request blocking，点击+，比如输入log*.js，log.js相关的就不会执行了

Diagnostics诊断

### 5.Chrome DevTools【最大法宝】

①关于size：资源压缩
上面的size代表网络传输过去size的大小
下面的size代表所加载资源实际的大小
两者可以不同，资源压缩后，减少传输大小

②performance：性能分析
刷新或者点击小圆点重新记录，性能分析
main：主线程
	拖动需要点击住再进行拖动
timings：关键的时间节点

③network
性能测评时disable-cache 取消掉，需要知道设置的缓存在第二次请求及后面请求有没有生效
throttling可以自定义设置吞吐量

④more tools
rendering渲染
	paint flashing 滚动时产生的重绘（重绘元素变为绿色）
	fps meter 监测动画帧数
performance monitor性能检测
	可以监测dom节点数，cpu、js堆占用，布局、样式重绘计算

### 6.常用的性能测量APIs--动态测量

浏览器核心工作轴/ 从输入 url 到页面呈现，浏览器核心工作过程  https://blog.csdn.net/weixin_44135121/article/details/103952234 

**第 1 步 开始计时**
startTime：记录开始时间。

**第 2 步 重定向**
redirectStart：重定向开始时间。
redirectEnd：重定向结束时间。

**第 3 步 浏览器与服务器连接**
fetchStart：浏览器发起 HTTP 请求时间。
domainLookupStart：DNS 查询开始时间。
domainLookupEnd：DNS 查询结束时间。
connectStart：TCP 连接开始时间。
connectEnd：TCP 连接结束时间。

**第 4 步 浏览器与服务器数据交互**
secureConnectionStart：浏览器跟服务器建立安全连接的时间。
requestStart：浏览器向服务器开始发送数据的时间。
responseStart：服务器向浏览器开始发送数据的时间。
responseEnd：服务器向浏览器结束发送数据的时间。

**第 5 步 浏览器 DOM 解析**
domLoading：DOM 开始解析的时间。
domInteractive：DOM 解析完成，开始加载内嵌资源的时间。
domContentLoadedEventStart：需要被执行的脚本已经被解析的时间。
domContentLoadedEventEnd：需要立即执行的脚本已经被执行的时间。
domComplete：文档解析完毕的时间。

补充： *loadEventStart*和loadEventEnd分别代表onload事件触发和结束的时间节点 

API实例
 https://blog.csdn.net/qiwoo_weekly/article/details/102791689 

```
window.addEventListener('load', function() {
    //performance.getEntries() 方法可以查询所有资源的耗时，performance.getEntriesByType可以根据资源类型来查	   //看某种类型的资源耗时
    let t = performance.getEntriesByType('navigation')[0]
    
    //tti：Time to Interactive用户可交互时间
    let tti = t.domInteractive - t.fetchStart
});

//通过api去发现程序中的长任务
//通过performance得到所有的的long task任务
let observer = new PerformanceObserver((list)=>{
	for(const entry of list.getEntries()){
		//通过entry的duration可以看到时间
		console.log(entry)
	}
})
//监听longtask这种类型
observer.observe({entryTypes: ['longtask']})

//知道用户显示状态 ui api
let vEvent = 'visibilitychange';
if(document.webkitHidden != undefined){
	// webkit 事件名称
	vEvent = 'webkitvisibilitychange'
}
function visibilityChanged(){
	if(document.hidden || document.webkitHidden){
		console.log('web page is hidden')
	}else{
		//页面可见
		console.log('web page is visible')
	}
}
window.addEventListener('vEvent', visibilityChanged, false);

//知道网络状态network API
//在控制台输出
let connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection
let type = connection.effectiveType
function updateConnectionStatus(){
	console.log('connection type changed from'+ type + 'to' + connection.effectiveType)
}
window.addEventListener('change', updateConnectionStatus);
//随便调整network的吞吐可以看到变化

//关键时间节点算法
1、DNS查询耗时
	t.domainLookupEnd - t.domainLookupStart || 0;
2、TCP建立连接耗时
	t.connectEnd - t.connectStart;
3、SSL安全链接耗时
	t.connectEnd - t.secureConnectionStart;
4、TTFB网络请求耗时
	t.responseStart - t.requestStart;
5、数据传输耗时
	t.responseEnd - t.responseStart
6、Dom结构解析耗时
    body完成,header中写的js(不含defer属性)会影响该值
    t.domInteractive - t.responseEnd;
7、资源加载耗时
	t.loadEventStart - t.domContentLoadedEventEnd 
8、first byte时间/首包时间
	HTTP通讯响应时间，自你发送完请求后，到服务器返回给你第一个信息中间的耗时
	t.responseStart - t.domainLookupStart
9、白屏时间
	t.responseEnd - t.fetchStart
10、首次可交互时间
	 t.domInteractive - t.fetchStart
11、dom ready时间
	t.domContentLoadEventEnd - t.fetchStart
12、页面完全加载时间
	t.loadEventStart - t.fetchStart
13、http头部大小
	t.transferSize - t.encodedBodySize
14、重定向次数
	performance.navigation.redirectCount
15、首屏加载时间
	domComplete - navigationStart
```

## 二.渲染优化

### 1.关键渲染路径

浏览器渲染原理：
读取html，css文本，构建DOM树。（DOM ，CSSDOM）- DOMtree 

关键渲染路径：5个步骤
javascript（js或者css动画触发视觉变化） - style（样式计算，css改变） - Layout（布局）- Paint（绘制）- Composite（合层）

### 2.回流与重绘，避免布局抖动

#### 2.1区分布局绘制、回流

布局关心的是位置和大小。（如css：height，offset改变位置，大小---几何信息）
如果只是更改background，opcity，不需要Layout（布局），只需Paint（重绘） 
首次加载叫布局，再次叫回流

#### 2.2 影响回流的操作 

- 　添加/删除 元素，
- 　操作styles，display：none。
- 　offsetLeft，offsetTop ，scrollTop，clientWidth。使用这些属性，会引起强制布局更新。
- 移动元素位置
- 　修改浏览器大小，字体大小

#### 2.3  回流不可避免的情况 - 布局抖动（layout thrashing） 

 连续的读（获取offset等）写（赋值给宽高等）操作，会引起强制的布局更新，强制布局更新会造成页面抖动
 如何查看：
     通过devtools，performance 可以查看回流的过程，在onLoad后的timing（长任务有三角标志），Layout--forceReflow
 解决布局抖动方案：
	 避免回流，读写分离
	 批量的读 (var wid = element.clientWidth;），批量的写入 (element.style.width = wid + 'px';) 

#### 2.4使用FastDom 解决布局抖动(流行)

 https://github.com/wilsonpage/fastdom 

```
const fn = (param)=>{
	fastdom.measure(() => {
      //measure读操作
      fastdom.mutate(() => {
          //mutate写操作
          console.log('mutate');
        });
    });
}

window.requestAnimationFrame(fn)
```

#### 2.5复合线程(compositor thread)与图层

  复合线程做了什么

- 将页面拆分图层进行绘制再进行复合
- 利用DevTools了解网页的图层拆分情况（如何看图层）---frames---layers
- 哪些样式仅影响复合

哪些样式仅影响复合（避免重绘 ）

- transform:translate/scale(代替width、height)、ratotion
- opacity

#### 2.6减少重绘

利用DevTools：rendering--paint flashing识别paint重绘图层

利用will-change创建新的图层（必须考虑数量和必要性）

- 如果静态图层和动画图层在同一层级的时候，会产生抖动，这时候需要使用will-change，改变其效果

- 移动端尽量少用，因为会引起cpu内存问题，pc端适量去用，最好在优化后可以在动画完成取消优化，如果动画连续且使用的不多，可以使用will-change

```
{
	https://www.cnblogs.com/yuzhongwusan/p/4186405.html
	// `will-change` 为web开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作 
	//浏览器知道元素被提取到单独的图层
	will-change: transform;
}
```

#### 2.7高频事件防抖

scorll、pointermove（鼠标滑动）、mousemove、touch，卡顿问题

帧数生命周期：raf在布局layout、paint之前触发，requestAnimationFrame属于raf

```
//如果某个函数会改变网页的布局，一般就放在window.requestAnimationFrame()里面执行，这样可以节省系统资源，使得网页效果更加平滑。因为慢速设备会用较慢的速率重流和重绘，而速度更快的设备会有更快的速率。
//window.requestAnimationFrame()则是推迟到浏览器下一次重流时执行，执行完才会进行下一次重绘。重绘通常是 16ms 执行一次
window.requestAnimationFrame(callback)//该方法接受一个回调函数作为参数

var ticking = false;
window.addEventListener('pointermove', e => {
	let pos = e.clientX;
	if(ticking) return false;
	ticking = true;
	window.requestAnimationFrame(()=>{
	
		//change width function
		
		ticking = false; //事件执行后可以再触发下一个requestAnimationFrame
	})
})


//underscore中
{
	// 第六版
    function debounce(func, wait, immediate) {

        var timeout, result;

        var debounced = function () {
            var context = this;
            var args = arguments;

            if (timeout) clearTimeout(timeout);
            if (immediate) {
                // 如果已经执行过，不再执行
                var callNow = !timeout;
                timeout = setTimeout(function(){
                    timeout = null;
                }, wait)
                if (callNow) result = func.apply(context, args)
            }
            else {
                timeout = setTimeout(function(){
                    result = func.apply(context, args)
                }, wait);
            }
            return result;
        };

        debounced.cancel = function() {
            clearTimeout(timeout);
            timeout = null;
        };

        return debounced;
    }
    
    //调用
    let debouncedFn = debounce(fn, 1000, false)//注意fn不能加括号
 
    window.addEventListener('resize', async () => {
      let val
      try {
        val = await debouncedFn(4)
      } catch (err) {
        console.error(err)
      }
      console.log(`原函数返回值为${val}`)
    }, false)

}
```

#### 2.8时间调度实现（react）（rIC）

帧数生命周期：requestIdecallback在布局layout、paint之后触发， 将在浏览器的空闲时段内调用的函数排队 
你可以在空闲回调函数中调用requestIdleCallback() （rIC），以便在下一次通过事件循环之前调度另一个回调 

一些低优先级的任务可使用 `requestIdleCallback` 等浏览器不忙的时候来执行，同时因为时间有限，它所执行的任务应该尽量是能够量化，细分的微任务（micro task）

因为它发生在一帧的最后，此时页面布局已经完成，**所以不建议在 `requestIdleCallback` 里再操作 DOM**，这样会导致页面再次重绘。**DOM 操作建议在 rAF 中进行**。同时，操作 DOM 所需要的耗时是不确定的，因为会导致重新计算布局和视图的绘制，所以这类操作不具备可预测性。

**Promise 也不建议在这里面进行**，因为 Promise 的回调属性 Event loop 中优先级较高的一种微任务，会在 requestIdleCallback结束时立即执行，不管此时是否还有富余的时间，这样有很大可能会让一帧超过 16 ms。

#### 一些概念难点

https://segmentfault.com/a/1190000019154514

https://time.geekbang.org/column/article/169468

## 三.代码优化

#### 1.代码拆分，按需加载（code splitting）

 当前访问路径需要哪些资源就加载哪些资源，不需要的我们给它延迟，访问的时候再去加载。达到减少加载js的目的 

#### 2.代码减重（tree shaking）

 只是引用了loadsh里面的一个函数，就可以把这一个函数打包到bundle文件中 

#### 3.减少主线程工作量

- 避免长任务

  任务时间越长，占据的阻塞越久 

- 避免超过1kb的行间脚本

  写行间脚本可能是为了加快首屏的渲染。剩下的再通过web文件进行加载。

  对于行间脚本，浏览器不能进行优化

- 使用raf和ric进行时间调度